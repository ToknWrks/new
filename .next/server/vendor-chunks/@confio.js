"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@confio";
exports.ids = ["vendor-chunks/@confio"];
exports.modules = {

/***/ "(ssr)/./node_modules/@confio/ics23/build/compress.js":
/*!******************************************************!*\
  !*** ./node_modules/@confio/ics23/build/compress.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decompress = exports.compress = void 0;\nconst codecimpl_1 = __webpack_require__(/*! ./generated/codecimpl */ \"(ssr)/./node_modules/@confio/ics23/build/generated/codecimpl.js\");\nfunction compress(proof) {\n    if (!proof.batch) {\n        return proof;\n    }\n    return { compressed: compressBatch(proof.batch) };\n}\nexports.compress = compress;\nfunction decompress(proof) {\n    if (!proof.compressed) {\n        return proof;\n    }\n    return { batch: decompressBatch(proof.compressed) };\n}\nexports.decompress = decompress;\nfunction compressBatch(proof) {\n    const centries = [];\n    const lookup = [];\n    const registry = new Map();\n    for (const entry of proof.entries) {\n        if (entry.exist) {\n            const centry = { exist: compressExist(entry.exist, lookup, registry) };\n            centries.push(centry);\n        }\n        else if (entry.nonexist) {\n            const non = entry.nonexist;\n            const centry = {\n                nonexist: {\n                    key: non.key,\n                    left: compressExist(non.left, lookup, registry),\n                    right: compressExist(non.right, lookup, registry),\n                },\n            };\n            centries.push(centry);\n        }\n        else {\n            throw new Error(\"Unexpected batch entry during compress\");\n        }\n    }\n    return {\n        entries: centries,\n        lookupInners: lookup,\n    };\n}\nfunction compressExist(exist, lookup, registry) {\n    if (!exist) {\n        return undefined;\n    }\n    const path = exist.path.map((inner) => {\n        const sig = codecimpl_1.ics23.InnerOp.encode(inner).finish();\n        let idx = registry.get(sig);\n        if (idx === undefined) {\n            idx = lookup.length;\n            lookup.push(inner);\n            registry.set(sig, idx);\n        }\n        return idx;\n    });\n    return {\n        key: exist.key,\n        value: exist.value,\n        leaf: exist.leaf,\n        path,\n    };\n}\nfunction decompressBatch(proof) {\n    const lookup = proof.lookupInners;\n    const entries = proof.entries.map((comp) => {\n        if (comp.exist) {\n            return { exist: decompressExist(comp.exist, lookup) };\n        }\n        else if (comp.nonexist) {\n            const non = comp.nonexist;\n            return {\n                nonexist: {\n                    key: non.key,\n                    left: decompressExist(non.left, lookup),\n                    right: decompressExist(non.right, lookup),\n                },\n            };\n        }\n        else {\n            throw new Error(\"Unexpected batch entry during compress\");\n        }\n    });\n    return {\n        entries,\n    };\n}\nfunction decompressExist(exist, lookup) {\n    if (!exist) {\n        return undefined;\n    }\n    const { key, value, leaf, path } = exist;\n    const newPath = (path || []).map((idx) => lookup[idx]);\n    return { key, value, leaf, path: newPath };\n}\n//# sourceMappingURL=compress.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbmZpby9pY3MyMy9idWlsZC9jb21wcmVzcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyxnQkFBZ0I7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMsOEZBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0EsYUFBYTtBQUNiO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVuLXByby1uZXh0Ly4vbm9kZV9tb2R1bGVzL0Bjb25maW8vaWNzMjMvYnVpbGQvY29tcHJlc3MuanM/OTc0NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb21wcmVzcyA9IGV4cG9ydHMuY29tcHJlc3MgPSB2b2lkIDA7XG5jb25zdCBjb2RlY2ltcGxfMSA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlZC9jb2RlY2ltcGxcIik7XG5mdW5jdGlvbiBjb21wcmVzcyhwcm9vZikge1xuICAgIGlmICghcHJvb2YuYmF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHByb29mO1xuICAgIH1cbiAgICByZXR1cm4geyBjb21wcmVzc2VkOiBjb21wcmVzc0JhdGNoKHByb29mLmJhdGNoKSB9O1xufVxuZXhwb3J0cy5jb21wcmVzcyA9IGNvbXByZXNzO1xuZnVuY3Rpb24gZGVjb21wcmVzcyhwcm9vZikge1xuICAgIGlmICghcHJvb2YuY29tcHJlc3NlZCkge1xuICAgICAgICByZXR1cm4gcHJvb2Y7XG4gICAgfVxuICAgIHJldHVybiB7IGJhdGNoOiBkZWNvbXByZXNzQmF0Y2gocHJvb2YuY29tcHJlc3NlZCkgfTtcbn1cbmV4cG9ydHMuZGVjb21wcmVzcyA9IGRlY29tcHJlc3M7XG5mdW5jdGlvbiBjb21wcmVzc0JhdGNoKHByb29mKSB7XG4gICAgY29uc3QgY2VudHJpZXMgPSBbXTtcbiAgICBjb25zdCBsb29rdXAgPSBbXTtcbiAgICBjb25zdCByZWdpc3RyeSA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHByb29mLmVudHJpZXMpIHtcbiAgICAgICAgaWYgKGVudHJ5LmV4aXN0KSB7XG4gICAgICAgICAgICBjb25zdCBjZW50cnkgPSB7IGV4aXN0OiBjb21wcmVzc0V4aXN0KGVudHJ5LmV4aXN0LCBsb29rdXAsIHJlZ2lzdHJ5KSB9O1xuICAgICAgICAgICAgY2VudHJpZXMucHVzaChjZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVudHJ5Lm5vbmV4aXN0KSB7XG4gICAgICAgICAgICBjb25zdCBub24gPSBlbnRyeS5ub25leGlzdDtcbiAgICAgICAgICAgIGNvbnN0IGNlbnRyeSA9IHtcbiAgICAgICAgICAgICAgICBub25leGlzdDoge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IG5vbi5rZXksXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGNvbXByZXNzRXhpc3Qobm9uLmxlZnQsIGxvb2t1cCwgcmVnaXN0cnkpLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogY29tcHJlc3NFeGlzdChub24ucmlnaHQsIGxvb2t1cCwgcmVnaXN0cnkpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2VudHJpZXMucHVzaChjZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBiYXRjaCBlbnRyeSBkdXJpbmcgY29tcHJlc3NcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW50cmllczogY2VudHJpZXMsXG4gICAgICAgIGxvb2t1cElubmVyczogbG9va3VwLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb21wcmVzc0V4aXN0KGV4aXN0LCBsb29rdXAsIHJlZ2lzdHJ5KSB7XG4gICAgaWYgKCFleGlzdCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBwYXRoID0gZXhpc3QucGF0aC5tYXAoKGlubmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHNpZyA9IGNvZGVjaW1wbF8xLmljczIzLklubmVyT3AuZW5jb2RlKGlubmVyKS5maW5pc2goKTtcbiAgICAgICAgbGV0IGlkeCA9IHJlZ2lzdHJ5LmdldChzaWcpO1xuICAgICAgICBpZiAoaWR4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlkeCA9IGxvb2t1cC5sZW5ndGg7XG4gICAgICAgICAgICBsb29rdXAucHVzaChpbm5lcik7XG4gICAgICAgICAgICByZWdpc3RyeS5zZXQoc2lnLCBpZHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBleGlzdC5rZXksXG4gICAgICAgIHZhbHVlOiBleGlzdC52YWx1ZSxcbiAgICAgICAgbGVhZjogZXhpc3QubGVhZixcbiAgICAgICAgcGF0aCxcbiAgICB9O1xufVxuZnVuY3Rpb24gZGVjb21wcmVzc0JhdGNoKHByb29mKSB7XG4gICAgY29uc3QgbG9va3VwID0gcHJvb2YubG9va3VwSW5uZXJzO1xuICAgIGNvbnN0IGVudHJpZXMgPSBwcm9vZi5lbnRyaWVzLm1hcCgoY29tcCkgPT4ge1xuICAgICAgICBpZiAoY29tcC5leGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXhpc3Q6IGRlY29tcHJlc3NFeGlzdChjb21wLmV4aXN0LCBsb29rdXApIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcC5ub25leGlzdCkge1xuICAgICAgICAgICAgY29uc3Qgbm9uID0gY29tcC5ub25leGlzdDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbm9uZXhpc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBub24ua2V5LFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBkZWNvbXByZXNzRXhpc3Qobm9uLmxlZnQsIGxvb2t1cCksXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBkZWNvbXByZXNzRXhpc3Qobm9uLnJpZ2h0LCBsb29rdXApLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBiYXRjaCBlbnRyeSBkdXJpbmcgY29tcHJlc3NcIik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbnRyaWVzLFxuICAgIH07XG59XG5mdW5jdGlvbiBkZWNvbXByZXNzRXhpc3QoZXhpc3QsIGxvb2t1cCkge1xuICAgIGlmICghZXhpc3QpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgeyBrZXksIHZhbHVlLCBsZWFmLCBwYXRoIH0gPSBleGlzdDtcbiAgICBjb25zdCBuZXdQYXRoID0gKHBhdGggfHwgW10pLm1hcCgoaWR4KSA9PiBsb29rdXBbaWR4XSk7XG4gICAgcmV0dXJuIHsga2V5LCB2YWx1ZSwgbGVhZiwgcGF0aDogbmV3UGF0aCB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcHJlc3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@confio/ics23/build/compress.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@confio/ics23/build/generated/codecimpl.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@confio/ics23/build/generated/codecimpl.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\n\nvar $protobuf = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n\n// Common aliases\nvar $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.ics23 = (function() {\n\n    /**\n     * Namespace ics23.\n     * @exports ics23\n     * @namespace\n     */\n    var ics23 = {};\n\n    /**\n     * HashOp enum.\n     * @name ics23.HashOp\n     * @enum {string}\n     * @property {number} NO_HASH=0 NO_HASH value\n     * @property {number} SHA256=1 SHA256 value\n     * @property {number} SHA512=2 SHA512 value\n     * @property {number} KECCAK=3 KECCAK value\n     * @property {number} RIPEMD160=4 RIPEMD160 value\n     * @property {number} BITCOIN=5 BITCOIN value\n     * @property {number} SHA512_256=6 SHA512_256 value\n     */\n    ics23.HashOp = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"NO_HASH\"] = 0;\n        values[valuesById[1] = \"SHA256\"] = 1;\n        values[valuesById[2] = \"SHA512\"] = 2;\n        values[valuesById[3] = \"KECCAK\"] = 3;\n        values[valuesById[4] = \"RIPEMD160\"] = 4;\n        values[valuesById[5] = \"BITCOIN\"] = 5;\n        values[valuesById[6] = \"SHA512_256\"] = 6;\n        return values;\n    })();\n\n    /**\n     * LengthOp defines how to process the key and value of the LeafOp\n     * to include length information. After encoding the length with the given\n     * algorithm, the length will be prepended to the key and value bytes.\n     * (Each one with it's own encoded length)\n     * @name ics23.LengthOp\n     * @enum {string}\n     * @property {number} NO_PREFIX=0 NO_PREFIX value\n     * @property {number} VAR_PROTO=1 VAR_PROTO value\n     * @property {number} VAR_RLP=2 VAR_RLP value\n     * @property {number} FIXED32_BIG=3 FIXED32_BIG value\n     * @property {number} FIXED32_LITTLE=4 FIXED32_LITTLE value\n     * @property {number} FIXED64_BIG=5 FIXED64_BIG value\n     * @property {number} FIXED64_LITTLE=6 FIXED64_LITTLE value\n     * @property {number} REQUIRE_32_BYTES=7 REQUIRE_32_BYTES value\n     * @property {number} REQUIRE_64_BYTES=8 REQUIRE_64_BYTES value\n     */\n    ics23.LengthOp = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"NO_PREFIX\"] = 0;\n        values[valuesById[1] = \"VAR_PROTO\"] = 1;\n        values[valuesById[2] = \"VAR_RLP\"] = 2;\n        values[valuesById[3] = \"FIXED32_BIG\"] = 3;\n        values[valuesById[4] = \"FIXED32_LITTLE\"] = 4;\n        values[valuesById[5] = \"FIXED64_BIG\"] = 5;\n        values[valuesById[6] = \"FIXED64_LITTLE\"] = 6;\n        values[valuesById[7] = \"REQUIRE_32_BYTES\"] = 7;\n        values[valuesById[8] = \"REQUIRE_64_BYTES\"] = 8;\n        return values;\n    })();\n\n    ics23.ExistenceProof = (function() {\n\n        /**\n         * Properties of an ExistenceProof.\n         * @memberof ics23\n         * @interface IExistenceProof\n         * @property {Uint8Array|null} [key] ExistenceProof key\n         * @property {Uint8Array|null} [value] ExistenceProof value\n         * @property {ics23.ILeafOp|null} [leaf] ExistenceProof leaf\n         * @property {Array.<ics23.IInnerOp>|null} [path] ExistenceProof path\n         */\n\n        /**\n         * Constructs a new ExistenceProof.\n         * @memberof ics23\n         * @classdesc ExistenceProof takes a key and a value and a set of steps to perform on it.\n         * The result of peforming all these steps will provide a \"root hash\", which can\n         * be compared to the value in a header.\n         * \n         * Since it is computationally infeasible to produce a hash collission for any of the used\n         * cryptographic hash functions, if someone can provide a series of operations to transform\n         * a given key and value into a root hash that matches some trusted root, these key and values\n         * must be in the referenced merkle tree.\n         * \n         * The only possible issue is maliablity in LeafOp, such as providing extra prefix data,\n         * which should be controlled by a spec. Eg. with lengthOp as NONE,\n         * prefix = FOO, key = BAR, value = CHOICE\n         * and\n         * prefix = F, key = OOBAR, value = CHOICE\n         * would produce the same value.\n         * \n         * With LengthOp this is tricker but not impossible. Which is why the \"leafPrefixEqual\" field\n         * in the ProofSpec is valuable to prevent this mutability. And why all trees should\n         * length-prefix the data before hashing it.\n         * @implements IExistenceProof\n         * @constructor\n         * @param {ics23.IExistenceProof=} [properties] Properties to set\n         */\n        function ExistenceProof(properties) {\n            this.path = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ExistenceProof key.\n         * @member {Uint8Array} key\n         * @memberof ics23.ExistenceProof\n         * @instance\n         */\n        ExistenceProof.prototype.key = $util.newBuffer([]);\n\n        /**\n         * ExistenceProof value.\n         * @member {Uint8Array} value\n         * @memberof ics23.ExistenceProof\n         * @instance\n         */\n        ExistenceProof.prototype.value = $util.newBuffer([]);\n\n        /**\n         * ExistenceProof leaf.\n         * @member {ics23.ILeafOp|null|undefined} leaf\n         * @memberof ics23.ExistenceProof\n         * @instance\n         */\n        ExistenceProof.prototype.leaf = null;\n\n        /**\n         * ExistenceProof path.\n         * @member {Array.<ics23.IInnerOp>} path\n         * @memberof ics23.ExistenceProof\n         * @instance\n         */\n        ExistenceProof.prototype.path = $util.emptyArray;\n\n        /**\n         * Creates a new ExistenceProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {ics23.IExistenceProof=} [properties] Properties to set\n         * @returns {ics23.ExistenceProof} ExistenceProof instance\n         */\n        ExistenceProof.create = function create(properties) {\n            return new ExistenceProof(properties);\n        };\n\n        /**\n         * Encodes the specified ExistenceProof message. Does not implicitly {@link ics23.ExistenceProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {ics23.IExistenceProof} message ExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ExistenceProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\"))\n                $root.ics23.LeafOp.encode(message.leaf, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.path != null && message.path.length)\n                for (var i = 0; i < message.path.length; ++i)\n                    $root.ics23.InnerOp.encode(message.path[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified ExistenceProof message, length delimited. Does not implicitly {@link ics23.ExistenceProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {ics23.IExistenceProof} message ExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes an ExistenceProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.ExistenceProof} ExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ExistenceProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.ExistenceProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.value = reader.bytes();\n                    break;\n                case 3:\n                    message.leaf = $root.ics23.LeafOp.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    if (!(message.path && message.path.length))\n                        message.path = [];\n                    message.path.push($root.ics23.InnerOp.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes an ExistenceProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.ExistenceProof} ExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies an ExistenceProof message.\n         * @function verify\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        ExistenceProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key)))\n                    return \"key: buffer expected\";\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                if (!(message.value && typeof message.value.length === \"number\" || $util.isString(message.value)))\n                    return \"value: buffer expected\";\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\")) {\n                var error = $root.ics23.LeafOp.verify(message.leaf);\n                if (error)\n                    return \"leaf.\" + error;\n            }\n            if (message.path != null && message.hasOwnProperty(\"path\")) {\n                if (!Array.isArray(message.path))\n                    return \"path: array expected\";\n                for (var i = 0; i < message.path.length; ++i) {\n                    var error = $root.ics23.InnerOp.verify(message.path[i]);\n                    if (error)\n                        return \"path.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates an ExistenceProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.ExistenceProof} ExistenceProof\n         */\n        ExistenceProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.ExistenceProof)\n                return object;\n            var message = new $root.ics23.ExistenceProof();\n            if (object.key != null)\n                if (typeof object.key === \"string\")\n                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);\n                else if (object.key.length)\n                    message.key = object.key;\n            if (object.value != null)\n                if (typeof object.value === \"string\")\n                    $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);\n                else if (object.value.length)\n                    message.value = object.value;\n            if (object.leaf != null) {\n                if (typeof object.leaf !== \"object\")\n                    throw TypeError(\".ics23.ExistenceProof.leaf: object expected\");\n                message.leaf = $root.ics23.LeafOp.fromObject(object.leaf);\n            }\n            if (object.path) {\n                if (!Array.isArray(object.path))\n                    throw TypeError(\".ics23.ExistenceProof.path: array expected\");\n                message.path = [];\n                for (var i = 0; i < object.path.length; ++i) {\n                    if (typeof object.path[i] !== \"object\")\n                        throw TypeError(\".ics23.ExistenceProof.path: object expected\");\n                    message.path[i] = $root.ics23.InnerOp.fromObject(object.path[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from an ExistenceProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {ics23.ExistenceProof} message ExistenceProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        ExistenceProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.path = [];\n            if (options.defaults) {\n                if (options.bytes === String)\n                    object.key = \"\";\n                else {\n                    object.key = [];\n                    if (options.bytes !== Array)\n                        object.key = $util.newBuffer(object.key);\n                }\n                if (options.bytes === String)\n                    object.value = \"\";\n                else {\n                    object.value = [];\n                    if (options.bytes !== Array)\n                        object.value = $util.newBuffer(object.value);\n                }\n                object.leaf = null;\n            }\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\"))\n                object.leaf = $root.ics23.LeafOp.toObject(message.leaf, options);\n            if (message.path && message.path.length) {\n                object.path = [];\n                for (var j = 0; j < message.path.length; ++j)\n                    object.path[j] = $root.ics23.InnerOp.toObject(message.path[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this ExistenceProof to JSON.\n         * @function toJSON\n         * @memberof ics23.ExistenceProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        ExistenceProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ExistenceProof;\n    })();\n\n    ics23.NonExistenceProof = (function() {\n\n        /**\n         * Properties of a NonExistenceProof.\n         * @memberof ics23\n         * @interface INonExistenceProof\n         * @property {Uint8Array|null} [key] NonExistenceProof key\n         * @property {ics23.IExistenceProof|null} [left] NonExistenceProof left\n         * @property {ics23.IExistenceProof|null} [right] NonExistenceProof right\n         */\n\n        /**\n         * Constructs a new NonExistenceProof.\n         * @memberof ics23\n         * @classdesc Represents a NonExistenceProof.\n         * @implements INonExistenceProof\n         * @constructor\n         * @param {ics23.INonExistenceProof=} [properties] Properties to set\n         */\n        function NonExistenceProof(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * NonExistenceProof key.\n         * @member {Uint8Array} key\n         * @memberof ics23.NonExistenceProof\n         * @instance\n         */\n        NonExistenceProof.prototype.key = $util.newBuffer([]);\n\n        /**\n         * NonExistenceProof left.\n         * @member {ics23.IExistenceProof|null|undefined} left\n         * @memberof ics23.NonExistenceProof\n         * @instance\n         */\n        NonExistenceProof.prototype.left = null;\n\n        /**\n         * NonExistenceProof right.\n         * @member {ics23.IExistenceProof|null|undefined} right\n         * @memberof ics23.NonExistenceProof\n         * @instance\n         */\n        NonExistenceProof.prototype.right = null;\n\n        /**\n         * Creates a new NonExistenceProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {ics23.INonExistenceProof=} [properties] Properties to set\n         * @returns {ics23.NonExistenceProof} NonExistenceProof instance\n         */\n        NonExistenceProof.create = function create(properties) {\n            return new NonExistenceProof(properties);\n        };\n\n        /**\n         * Encodes the specified NonExistenceProof message. Does not implicitly {@link ics23.NonExistenceProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {ics23.INonExistenceProof} message NonExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        NonExistenceProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);\n            if (message.left != null && message.hasOwnProperty(\"left\"))\n                $root.ics23.ExistenceProof.encode(message.left, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.right != null && message.hasOwnProperty(\"right\"))\n                $root.ics23.ExistenceProof.encode(message.right, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified NonExistenceProof message, length delimited. Does not implicitly {@link ics23.NonExistenceProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {ics23.INonExistenceProof} message NonExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        NonExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a NonExistenceProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.NonExistenceProof} NonExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        NonExistenceProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.NonExistenceProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.left = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.right = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a NonExistenceProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.NonExistenceProof} NonExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        NonExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a NonExistenceProof message.\n         * @function verify\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        NonExistenceProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key)))\n                    return \"key: buffer expected\";\n            if (message.left != null && message.hasOwnProperty(\"left\")) {\n                var error = $root.ics23.ExistenceProof.verify(message.left);\n                if (error)\n                    return \"left.\" + error;\n            }\n            if (message.right != null && message.hasOwnProperty(\"right\")) {\n                var error = $root.ics23.ExistenceProof.verify(message.right);\n                if (error)\n                    return \"right.\" + error;\n            }\n            return null;\n        };\n\n        /**\n         * Creates a NonExistenceProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.NonExistenceProof} NonExistenceProof\n         */\n        NonExistenceProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.NonExistenceProof)\n                return object;\n            var message = new $root.ics23.NonExistenceProof();\n            if (object.key != null)\n                if (typeof object.key === \"string\")\n                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);\n                else if (object.key.length)\n                    message.key = object.key;\n            if (object.left != null) {\n                if (typeof object.left !== \"object\")\n                    throw TypeError(\".ics23.NonExistenceProof.left: object expected\");\n                message.left = $root.ics23.ExistenceProof.fromObject(object.left);\n            }\n            if (object.right != null) {\n                if (typeof object.right !== \"object\")\n                    throw TypeError(\".ics23.NonExistenceProof.right: object expected\");\n                message.right = $root.ics23.ExistenceProof.fromObject(object.right);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a NonExistenceProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {ics23.NonExistenceProof} message NonExistenceProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        NonExistenceProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                if (options.bytes === String)\n                    object.key = \"\";\n                else {\n                    object.key = [];\n                    if (options.bytes !== Array)\n                        object.key = $util.newBuffer(object.key);\n                }\n                object.left = null;\n                object.right = null;\n            }\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n            if (message.left != null && message.hasOwnProperty(\"left\"))\n                object.left = $root.ics23.ExistenceProof.toObject(message.left, options);\n            if (message.right != null && message.hasOwnProperty(\"right\"))\n                object.right = $root.ics23.ExistenceProof.toObject(message.right, options);\n            return object;\n        };\n\n        /**\n         * Converts this NonExistenceProof to JSON.\n         * @function toJSON\n         * @memberof ics23.NonExistenceProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        NonExistenceProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return NonExistenceProof;\n    })();\n\n    ics23.CommitmentProof = (function() {\n\n        /**\n         * Properties of a CommitmentProof.\n         * @memberof ics23\n         * @interface ICommitmentProof\n         * @property {ics23.IExistenceProof|null} [exist] CommitmentProof exist\n         * @property {ics23.INonExistenceProof|null} [nonexist] CommitmentProof nonexist\n         * @property {ics23.IBatchProof|null} [batch] CommitmentProof batch\n         * @property {ics23.ICompressedBatchProof|null} [compressed] CommitmentProof compressed\n         */\n\n        /**\n         * Constructs a new CommitmentProof.\n         * @memberof ics23\n         * @classdesc Represents a CommitmentProof.\n         * @implements ICommitmentProof\n         * @constructor\n         * @param {ics23.ICommitmentProof=} [properties] Properties to set\n         */\n        function CommitmentProof(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CommitmentProof exist.\n         * @member {ics23.IExistenceProof|null|undefined} exist\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        CommitmentProof.prototype.exist = null;\n\n        /**\n         * CommitmentProof nonexist.\n         * @member {ics23.INonExistenceProof|null|undefined} nonexist\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        CommitmentProof.prototype.nonexist = null;\n\n        /**\n         * CommitmentProof batch.\n         * @member {ics23.IBatchProof|null|undefined} batch\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        CommitmentProof.prototype.batch = null;\n\n        /**\n         * CommitmentProof compressed.\n         * @member {ics23.ICompressedBatchProof|null|undefined} compressed\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        CommitmentProof.prototype.compressed = null;\n\n        // OneOf field names bound to virtual getters and setters\n        var $oneOfFields;\n\n        /**\n         * CommitmentProof proof.\n         * @member {\"exist\"|\"nonexist\"|\"batch\"|\"compressed\"|undefined} proof\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        Object.defineProperty(CommitmentProof.prototype, \"proof\", {\n            get: $util.oneOfGetter($oneOfFields = [\"exist\", \"nonexist\", \"batch\", \"compressed\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Creates a new CommitmentProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {ics23.ICommitmentProof=} [properties] Properties to set\n         * @returns {ics23.CommitmentProof} CommitmentProof instance\n         */\n        CommitmentProof.create = function create(properties) {\n            return new CommitmentProof(properties);\n        };\n\n        /**\n         * Encodes the specified CommitmentProof message. Does not implicitly {@link ics23.CommitmentProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {ics23.ICommitmentProof} message CommitmentProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CommitmentProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.exist != null && message.hasOwnProperty(\"exist\"))\n                $root.ics23.ExistenceProof.encode(message.exist, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\"))\n                $root.ics23.NonExistenceProof.encode(message.nonexist, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.batch != null && message.hasOwnProperty(\"batch\"))\n                $root.ics23.BatchProof.encode(message.batch, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.compressed != null && message.hasOwnProperty(\"compressed\"))\n                $root.ics23.CompressedBatchProof.encode(message.compressed, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CommitmentProof message, length delimited. Does not implicitly {@link ics23.CommitmentProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {ics23.ICommitmentProof} message CommitmentProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CommitmentProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CommitmentProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CommitmentProof} CommitmentProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CommitmentProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CommitmentProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.exist = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.nonexist = $root.ics23.NonExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.batch = $root.ics23.BatchProof.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.compressed = $root.ics23.CompressedBatchProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CommitmentProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CommitmentProof} CommitmentProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CommitmentProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CommitmentProof message.\n         * @function verify\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CommitmentProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            var properties = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.ExistenceProof.verify(message.exist);\n                    if (error)\n                        return \"exist.\" + error;\n                }\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.NonExistenceProof.verify(message.nonexist);\n                    if (error)\n                        return \"nonexist.\" + error;\n                }\n            }\n            if (message.batch != null && message.hasOwnProperty(\"batch\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.BatchProof.verify(message.batch);\n                    if (error)\n                        return \"batch.\" + error;\n                }\n            }\n            if (message.compressed != null && message.hasOwnProperty(\"compressed\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.CompressedBatchProof.verify(message.compressed);\n                    if (error)\n                        return \"compressed.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CommitmentProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CommitmentProof} CommitmentProof\n         */\n        CommitmentProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CommitmentProof)\n                return object;\n            var message = new $root.ics23.CommitmentProof();\n            if (object.exist != null) {\n                if (typeof object.exist !== \"object\")\n                    throw TypeError(\".ics23.CommitmentProof.exist: object expected\");\n                message.exist = $root.ics23.ExistenceProof.fromObject(object.exist);\n            }\n            if (object.nonexist != null) {\n                if (typeof object.nonexist !== \"object\")\n                    throw TypeError(\".ics23.CommitmentProof.nonexist: object expected\");\n                message.nonexist = $root.ics23.NonExistenceProof.fromObject(object.nonexist);\n            }\n            if (object.batch != null) {\n                if (typeof object.batch !== \"object\")\n                    throw TypeError(\".ics23.CommitmentProof.batch: object expected\");\n                message.batch = $root.ics23.BatchProof.fromObject(object.batch);\n            }\n            if (object.compressed != null) {\n                if (typeof object.compressed !== \"object\")\n                    throw TypeError(\".ics23.CommitmentProof.compressed: object expected\");\n                message.compressed = $root.ics23.CompressedBatchProof.fromObject(object.compressed);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CommitmentProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {ics23.CommitmentProof} message CommitmentProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CommitmentProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                object.exist = $root.ics23.ExistenceProof.toObject(message.exist, options);\n                if (options.oneofs)\n                    object.proof = \"exist\";\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                object.nonexist = $root.ics23.NonExistenceProof.toObject(message.nonexist, options);\n                if (options.oneofs)\n                    object.proof = \"nonexist\";\n            }\n            if (message.batch != null && message.hasOwnProperty(\"batch\")) {\n                object.batch = $root.ics23.BatchProof.toObject(message.batch, options);\n                if (options.oneofs)\n                    object.proof = \"batch\";\n            }\n            if (message.compressed != null && message.hasOwnProperty(\"compressed\")) {\n                object.compressed = $root.ics23.CompressedBatchProof.toObject(message.compressed, options);\n                if (options.oneofs)\n                    object.proof = \"compressed\";\n            }\n            return object;\n        };\n\n        /**\n         * Converts this CommitmentProof to JSON.\n         * @function toJSON\n         * @memberof ics23.CommitmentProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CommitmentProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CommitmentProof;\n    })();\n\n    ics23.LeafOp = (function() {\n\n        /**\n         * Properties of a LeafOp.\n         * @memberof ics23\n         * @interface ILeafOp\n         * @property {ics23.HashOp|null} [hash] LeafOp hash\n         * @property {ics23.HashOp|null} [prehashKey] LeafOp prehashKey\n         * @property {ics23.HashOp|null} [prehashValue] LeafOp prehashValue\n         * @property {ics23.LengthOp|null} [length] LeafOp length\n         * @property {Uint8Array|null} [prefix] LeafOp prefix\n         */\n\n        /**\n         * Constructs a new LeafOp.\n         * @memberof ics23\n         * @classdesc LeafOp represents the raw key-value data we wish to prove, and\n         * must be flexible to represent the internal transformation from\n         * the original key-value pairs into the basis hash, for many existing\n         * merkle trees.\n         * \n         * key and value are passed in. So that the signature of this operation is:\n         * leafOp(key, value) -> output\n         * \n         * To process this, first prehash the keys and values if needed (ANY means no hash in this case):\n         * hkey = prehashKey(key)\n         * hvalue = prehashValue(value)\n         * \n         * Then combine the bytes, and hash it\n         * output = hash(prefix || length(hkey) || hkey || length(hvalue) || hvalue)\n         * @implements ILeafOp\n         * @constructor\n         * @param {ics23.ILeafOp=} [properties] Properties to set\n         */\n        function LeafOp(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * LeafOp hash.\n         * @member {ics23.HashOp} hash\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.hash = 0;\n\n        /**\n         * LeafOp prehashKey.\n         * @member {ics23.HashOp} prehashKey\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.prehashKey = 0;\n\n        /**\n         * LeafOp prehashValue.\n         * @member {ics23.HashOp} prehashValue\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.prehashValue = 0;\n\n        /**\n         * LeafOp length.\n         * @member {ics23.LengthOp} length\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.length = 0;\n\n        /**\n         * LeafOp prefix.\n         * @member {Uint8Array} prefix\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.prefix = $util.newBuffer([]);\n\n        /**\n         * Creates a new LeafOp instance using the specified properties.\n         * @function create\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {ics23.ILeafOp=} [properties] Properties to set\n         * @returns {ics23.LeafOp} LeafOp instance\n         */\n        LeafOp.create = function create(properties) {\n            return new LeafOp(properties);\n        };\n\n        /**\n         * Encodes the specified LeafOp message. Does not implicitly {@link ics23.LeafOp.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {ics23.ILeafOp} message LeafOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        LeafOp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hash);\n            if (message.prehashKey != null && message.hasOwnProperty(\"prehashKey\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.prehashKey);\n            if (message.prehashValue != null && message.hasOwnProperty(\"prehashValue\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.prehashValue);\n            if (message.length != null && message.hasOwnProperty(\"length\"))\n                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.length);\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.prefix);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified LeafOp message, length delimited. Does not implicitly {@link ics23.LeafOp.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {ics23.ILeafOp} message LeafOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        LeafOp.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a LeafOp message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.LeafOp} LeafOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        LeafOp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.LeafOp();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.hash = reader.int32();\n                    break;\n                case 2:\n                    message.prehashKey = reader.int32();\n                    break;\n                case 3:\n                    message.prehashValue = reader.int32();\n                    break;\n                case 4:\n                    message.length = reader.int32();\n                    break;\n                case 5:\n                    message.prefix = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a LeafOp message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.LeafOp} LeafOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        LeafOp.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a LeafOp message.\n         * @function verify\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        LeafOp.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                switch (message.hash) {\n                default:\n                    return \"hash: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            if (message.prehashKey != null && message.hasOwnProperty(\"prehashKey\"))\n                switch (message.prehashKey) {\n                default:\n                    return \"prehashKey: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            if (message.prehashValue != null && message.hasOwnProperty(\"prehashValue\"))\n                switch (message.prehashValue) {\n                default:\n                    return \"prehashValue: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            if (message.length != null && message.hasOwnProperty(\"length\"))\n                switch (message.length) {\n                default:\n                    return \"length: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                case 7:\n                case 8:\n                    break;\n                }\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                if (!(message.prefix && typeof message.prefix.length === \"number\" || $util.isString(message.prefix)))\n                    return \"prefix: buffer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a LeafOp message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.LeafOp} LeafOp\n         */\n        LeafOp.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.LeafOp)\n                return object;\n            var message = new $root.ics23.LeafOp();\n            switch (object.hash) {\n            case \"NO_HASH\":\n            case 0:\n                message.hash = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.hash = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.hash = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.hash = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.hash = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.hash = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.hash = 6;\n                break;\n            }\n            switch (object.prehashKey) {\n            case \"NO_HASH\":\n            case 0:\n                message.prehashKey = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.prehashKey = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.prehashKey = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.prehashKey = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.prehashKey = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.prehashKey = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.prehashKey = 6;\n                break;\n            }\n            switch (object.prehashValue) {\n            case \"NO_HASH\":\n            case 0:\n                message.prehashValue = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.prehashValue = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.prehashValue = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.prehashValue = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.prehashValue = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.prehashValue = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.prehashValue = 6;\n                break;\n            }\n            switch (object.length) {\n            case \"NO_PREFIX\":\n            case 0:\n                message.length = 0;\n                break;\n            case \"VAR_PROTO\":\n            case 1:\n                message.length = 1;\n                break;\n            case \"VAR_RLP\":\n            case 2:\n                message.length = 2;\n                break;\n            case \"FIXED32_BIG\":\n            case 3:\n                message.length = 3;\n                break;\n            case \"FIXED32_LITTLE\":\n            case 4:\n                message.length = 4;\n                break;\n            case \"FIXED64_BIG\":\n            case 5:\n                message.length = 5;\n                break;\n            case \"FIXED64_LITTLE\":\n            case 6:\n                message.length = 6;\n                break;\n            case \"REQUIRE_32_BYTES\":\n            case 7:\n                message.length = 7;\n                break;\n            case \"REQUIRE_64_BYTES\":\n            case 8:\n                message.length = 8;\n                break;\n            }\n            if (object.prefix != null)\n                if (typeof object.prefix === \"string\")\n                    $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);\n                else if (object.prefix.length)\n                    message.prefix = object.prefix;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a LeafOp message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {ics23.LeafOp} message LeafOp\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        LeafOp.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.hash = options.enums === String ? \"NO_HASH\" : 0;\n                object.prehashKey = options.enums === String ? \"NO_HASH\" : 0;\n                object.prehashValue = options.enums === String ? \"NO_HASH\" : 0;\n                object.length = options.enums === String ? \"NO_PREFIX\" : 0;\n                if (options.bytes === String)\n                    object.prefix = \"\";\n                else {\n                    object.prefix = [];\n                    if (options.bytes !== Array)\n                        object.prefix = $util.newBuffer(object.prefix);\n                }\n            }\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;\n            if (message.prehashKey != null && message.hasOwnProperty(\"prehashKey\"))\n                object.prehashKey = options.enums === String ? $root.ics23.HashOp[message.prehashKey] : message.prehashKey;\n            if (message.prehashValue != null && message.hasOwnProperty(\"prehashValue\"))\n                object.prehashValue = options.enums === String ? $root.ics23.HashOp[message.prehashValue] : message.prehashValue;\n            if (message.length != null && message.hasOwnProperty(\"length\"))\n                object.length = options.enums === String ? $root.ics23.LengthOp[message.length] : message.length;\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;\n            return object;\n        };\n\n        /**\n         * Converts this LeafOp to JSON.\n         * @function toJSON\n         * @memberof ics23.LeafOp\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        LeafOp.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return LeafOp;\n    })();\n\n    ics23.InnerOp = (function() {\n\n        /**\n         * Properties of an InnerOp.\n         * @memberof ics23\n         * @interface IInnerOp\n         * @property {ics23.HashOp|null} [hash] InnerOp hash\n         * @property {Uint8Array|null} [prefix] InnerOp prefix\n         * @property {Uint8Array|null} [suffix] InnerOp suffix\n         */\n\n        /**\n         * Constructs a new InnerOp.\n         * @memberof ics23\n         * @classdesc InnerOp represents a merkle-proof step that is not a leaf.\n         * It represents concatenating two children and hashing them to provide the next result.\n         * \n         * The result of the previous step is passed in, so the signature of this op is:\n         * innerOp(child) -> output\n         * \n         * The result of applying InnerOp should be:\n         * output = op.hash(op.prefix || child || op.suffix)\n         * \n         * where the || operator is concatenation of binary data,\n         * and child is the result of hashing all the tree below this step.\n         * \n         * Any special data, like prepending child with the length, or prepending the entire operation with\n         * some value to differentiate from leaf nodes, should be included in prefix and suffix.\n         * If either of prefix or suffix is empty, we just treat it as an empty string\n         * @implements IInnerOp\n         * @constructor\n         * @param {ics23.IInnerOp=} [properties] Properties to set\n         */\n        function InnerOp(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * InnerOp hash.\n         * @member {ics23.HashOp} hash\n         * @memberof ics23.InnerOp\n         * @instance\n         */\n        InnerOp.prototype.hash = 0;\n\n        /**\n         * InnerOp prefix.\n         * @member {Uint8Array} prefix\n         * @memberof ics23.InnerOp\n         * @instance\n         */\n        InnerOp.prototype.prefix = $util.newBuffer([]);\n\n        /**\n         * InnerOp suffix.\n         * @member {Uint8Array} suffix\n         * @memberof ics23.InnerOp\n         * @instance\n         */\n        InnerOp.prototype.suffix = $util.newBuffer([]);\n\n        /**\n         * Creates a new InnerOp instance using the specified properties.\n         * @function create\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {ics23.IInnerOp=} [properties] Properties to set\n         * @returns {ics23.InnerOp} InnerOp instance\n         */\n        InnerOp.create = function create(properties) {\n            return new InnerOp(properties);\n        };\n\n        /**\n         * Encodes the specified InnerOp message. Does not implicitly {@link ics23.InnerOp.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {ics23.IInnerOp} message InnerOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        InnerOp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hash);\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.prefix);\n            if (message.suffix != null && message.hasOwnProperty(\"suffix\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.suffix);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified InnerOp message, length delimited. Does not implicitly {@link ics23.InnerOp.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {ics23.IInnerOp} message InnerOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        InnerOp.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes an InnerOp message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.InnerOp} InnerOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        InnerOp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.InnerOp();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.hash = reader.int32();\n                    break;\n                case 2:\n                    message.prefix = reader.bytes();\n                    break;\n                case 3:\n                    message.suffix = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes an InnerOp message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.InnerOp} InnerOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        InnerOp.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies an InnerOp message.\n         * @function verify\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        InnerOp.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                switch (message.hash) {\n                default:\n                    return \"hash: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                if (!(message.prefix && typeof message.prefix.length === \"number\" || $util.isString(message.prefix)))\n                    return \"prefix: buffer expected\";\n            if (message.suffix != null && message.hasOwnProperty(\"suffix\"))\n                if (!(message.suffix && typeof message.suffix.length === \"number\" || $util.isString(message.suffix)))\n                    return \"suffix: buffer expected\";\n            return null;\n        };\n\n        /**\n         * Creates an InnerOp message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.InnerOp} InnerOp\n         */\n        InnerOp.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.InnerOp)\n                return object;\n            var message = new $root.ics23.InnerOp();\n            switch (object.hash) {\n            case \"NO_HASH\":\n            case 0:\n                message.hash = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.hash = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.hash = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.hash = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.hash = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.hash = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.hash = 6;\n                break;\n            }\n            if (object.prefix != null)\n                if (typeof object.prefix === \"string\")\n                    $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);\n                else if (object.prefix.length)\n                    message.prefix = object.prefix;\n            if (object.suffix != null)\n                if (typeof object.suffix === \"string\")\n                    $util.base64.decode(object.suffix, message.suffix = $util.newBuffer($util.base64.length(object.suffix)), 0);\n                else if (object.suffix.length)\n                    message.suffix = object.suffix;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from an InnerOp message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {ics23.InnerOp} message InnerOp\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        InnerOp.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.hash = options.enums === String ? \"NO_HASH\" : 0;\n                if (options.bytes === String)\n                    object.prefix = \"\";\n                else {\n                    object.prefix = [];\n                    if (options.bytes !== Array)\n                        object.prefix = $util.newBuffer(object.prefix);\n                }\n                if (options.bytes === String)\n                    object.suffix = \"\";\n                else {\n                    object.suffix = [];\n                    if (options.bytes !== Array)\n                        object.suffix = $util.newBuffer(object.suffix);\n                }\n            }\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;\n            if (message.suffix != null && message.hasOwnProperty(\"suffix\"))\n                object.suffix = options.bytes === String ? $util.base64.encode(message.suffix, 0, message.suffix.length) : options.bytes === Array ? Array.prototype.slice.call(message.suffix) : message.suffix;\n            return object;\n        };\n\n        /**\n         * Converts this InnerOp to JSON.\n         * @function toJSON\n         * @memberof ics23.InnerOp\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        InnerOp.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return InnerOp;\n    })();\n\n    ics23.ProofSpec = (function() {\n\n        /**\n         * Properties of a ProofSpec.\n         * @memberof ics23\n         * @interface IProofSpec\n         * @property {ics23.ILeafOp|null} [leafSpec] ProofSpec leafSpec\n         * @property {ics23.IInnerSpec|null} [innerSpec] ProofSpec innerSpec\n         * @property {number|null} [maxDepth] ProofSpec maxDepth\n         * @property {number|null} [minDepth] ProofSpec minDepth\n         */\n\n        /**\n         * Constructs a new ProofSpec.\n         * @memberof ics23\n         * @classdesc ProofSpec defines what the expected parameters are for a given proof type.\n         * This can be stored in the client and used to validate any incoming proofs.\n         * \n         * verify(ProofSpec, Proof) -> Proof | Error\n         * \n         * As demonstrated in tests, if we don't fix the algorithm used to calculate the\n         * LeafHash for a given tree, there are many possible key-value pairs that can\n         * generate a given hash (by interpretting the preimage differently).\n         * We need this for proper security, requires client knows a priori what\n         * tree format server uses. But not in code, rather a configuration object.\n         * @implements IProofSpec\n         * @constructor\n         * @param {ics23.IProofSpec=} [properties] Properties to set\n         */\n        function ProofSpec(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ProofSpec leafSpec.\n         * @member {ics23.ILeafOp|null|undefined} leafSpec\n         * @memberof ics23.ProofSpec\n         * @instance\n         */\n        ProofSpec.prototype.leafSpec = null;\n\n        /**\n         * ProofSpec innerSpec.\n         * @member {ics23.IInnerSpec|null|undefined} innerSpec\n         * @memberof ics23.ProofSpec\n         * @instance\n         */\n        ProofSpec.prototype.innerSpec = null;\n\n        /**\n         * ProofSpec maxDepth.\n         * @member {number} maxDepth\n         * @memberof ics23.ProofSpec\n         * @instance\n         */\n        ProofSpec.prototype.maxDepth = 0;\n\n        /**\n         * ProofSpec minDepth.\n         * @member {number} minDepth\n         * @memberof ics23.ProofSpec\n         * @instance\n         */\n        ProofSpec.prototype.minDepth = 0;\n\n        /**\n         * Creates a new ProofSpec instance using the specified properties.\n         * @function create\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {ics23.IProofSpec=} [properties] Properties to set\n         * @returns {ics23.ProofSpec} ProofSpec instance\n         */\n        ProofSpec.create = function create(properties) {\n            return new ProofSpec(properties);\n        };\n\n        /**\n         * Encodes the specified ProofSpec message. Does not implicitly {@link ics23.ProofSpec.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {ics23.IProofSpec} message ProofSpec message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ProofSpec.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.leafSpec != null && message.hasOwnProperty(\"leafSpec\"))\n                $root.ics23.LeafOp.encode(message.leafSpec, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.innerSpec != null && message.hasOwnProperty(\"innerSpec\"))\n                $root.ics23.InnerSpec.encode(message.innerSpec, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.maxDepth != null && message.hasOwnProperty(\"maxDepth\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.maxDepth);\n            if (message.minDepth != null && message.hasOwnProperty(\"minDepth\"))\n                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.minDepth);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified ProofSpec message, length delimited. Does not implicitly {@link ics23.ProofSpec.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {ics23.IProofSpec} message ProofSpec message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ProofSpec.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a ProofSpec message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.ProofSpec} ProofSpec\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ProofSpec.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.ProofSpec();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.leafSpec = $root.ics23.LeafOp.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.innerSpec = $root.ics23.InnerSpec.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.maxDepth = reader.int32();\n                    break;\n                case 4:\n                    message.minDepth = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a ProofSpec message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.ProofSpec} ProofSpec\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ProofSpec.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a ProofSpec message.\n         * @function verify\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        ProofSpec.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.leafSpec != null && message.hasOwnProperty(\"leafSpec\")) {\n                var error = $root.ics23.LeafOp.verify(message.leafSpec);\n                if (error)\n                    return \"leafSpec.\" + error;\n            }\n            if (message.innerSpec != null && message.hasOwnProperty(\"innerSpec\")) {\n                var error = $root.ics23.InnerSpec.verify(message.innerSpec);\n                if (error)\n                    return \"innerSpec.\" + error;\n            }\n            if (message.maxDepth != null && message.hasOwnProperty(\"maxDepth\"))\n                if (!$util.isInteger(message.maxDepth))\n                    return \"maxDepth: integer expected\";\n            if (message.minDepth != null && message.hasOwnProperty(\"minDepth\"))\n                if (!$util.isInteger(message.minDepth))\n                    return \"minDepth: integer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a ProofSpec message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.ProofSpec} ProofSpec\n         */\n        ProofSpec.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.ProofSpec)\n                return object;\n            var message = new $root.ics23.ProofSpec();\n            if (object.leafSpec != null) {\n                if (typeof object.leafSpec !== \"object\")\n                    throw TypeError(\".ics23.ProofSpec.leafSpec: object expected\");\n                message.leafSpec = $root.ics23.LeafOp.fromObject(object.leafSpec);\n            }\n            if (object.innerSpec != null) {\n                if (typeof object.innerSpec !== \"object\")\n                    throw TypeError(\".ics23.ProofSpec.innerSpec: object expected\");\n                message.innerSpec = $root.ics23.InnerSpec.fromObject(object.innerSpec);\n            }\n            if (object.maxDepth != null)\n                message.maxDepth = object.maxDepth | 0;\n            if (object.minDepth != null)\n                message.minDepth = object.minDepth | 0;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a ProofSpec message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {ics23.ProofSpec} message ProofSpec\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        ProofSpec.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.leafSpec = null;\n                object.innerSpec = null;\n                object.maxDepth = 0;\n                object.minDepth = 0;\n            }\n            if (message.leafSpec != null && message.hasOwnProperty(\"leafSpec\"))\n                object.leafSpec = $root.ics23.LeafOp.toObject(message.leafSpec, options);\n            if (message.innerSpec != null && message.hasOwnProperty(\"innerSpec\"))\n                object.innerSpec = $root.ics23.InnerSpec.toObject(message.innerSpec, options);\n            if (message.maxDepth != null && message.hasOwnProperty(\"maxDepth\"))\n                object.maxDepth = message.maxDepth;\n            if (message.minDepth != null && message.hasOwnProperty(\"minDepth\"))\n                object.minDepth = message.minDepth;\n            return object;\n        };\n\n        /**\n         * Converts this ProofSpec to JSON.\n         * @function toJSON\n         * @memberof ics23.ProofSpec\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        ProofSpec.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ProofSpec;\n    })();\n\n    ics23.InnerSpec = (function() {\n\n        /**\n         * Properties of an InnerSpec.\n         * @memberof ics23\n         * @interface IInnerSpec\n         * @property {Array.<number>|null} [childOrder] InnerSpec childOrder\n         * @property {number|null} [childSize] InnerSpec childSize\n         * @property {number|null} [minPrefixLength] InnerSpec minPrefixLength\n         * @property {number|null} [maxPrefixLength] InnerSpec maxPrefixLength\n         * @property {Uint8Array|null} [emptyChild] InnerSpec emptyChild\n         * @property {ics23.HashOp|null} [hash] InnerSpec hash\n         */\n\n        /**\n         * Constructs a new InnerSpec.\n         * @memberof ics23\n         * @classdesc Represents an InnerSpec.\n         * @implements IInnerSpec\n         * @constructor\n         * @param {ics23.IInnerSpec=} [properties] Properties to set\n         */\n        function InnerSpec(properties) {\n            this.childOrder = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * InnerSpec childOrder.\n         * @member {Array.<number>} childOrder\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.childOrder = $util.emptyArray;\n\n        /**\n         * InnerSpec childSize.\n         * @member {number} childSize\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.childSize = 0;\n\n        /**\n         * InnerSpec minPrefixLength.\n         * @member {number} minPrefixLength\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.minPrefixLength = 0;\n\n        /**\n         * InnerSpec maxPrefixLength.\n         * @member {number} maxPrefixLength\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.maxPrefixLength = 0;\n\n        /**\n         * InnerSpec emptyChild.\n         * @member {Uint8Array} emptyChild\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.emptyChild = $util.newBuffer([]);\n\n        /**\n         * InnerSpec hash.\n         * @member {ics23.HashOp} hash\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.hash = 0;\n\n        /**\n         * Creates a new InnerSpec instance using the specified properties.\n         * @function create\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {ics23.IInnerSpec=} [properties] Properties to set\n         * @returns {ics23.InnerSpec} InnerSpec instance\n         */\n        InnerSpec.create = function create(properties) {\n            return new InnerSpec(properties);\n        };\n\n        /**\n         * Encodes the specified InnerSpec message. Does not implicitly {@link ics23.InnerSpec.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {ics23.IInnerSpec} message InnerSpec message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        InnerSpec.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.childOrder != null && message.childOrder.length) {\n                writer.uint32(/* id 1, wireType 2 =*/10).fork();\n                for (var i = 0; i < message.childOrder.length; ++i)\n                    writer.int32(message.childOrder[i]);\n                writer.ldelim();\n            }\n            if (message.childSize != null && message.hasOwnProperty(\"childSize\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.childSize);\n            if (message.minPrefixLength != null && message.hasOwnProperty(\"minPrefixLength\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.minPrefixLength);\n            if (message.maxPrefixLength != null && message.hasOwnProperty(\"maxPrefixLength\"))\n                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.maxPrefixLength);\n            if (message.emptyChild != null && message.hasOwnProperty(\"emptyChild\"))\n                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.emptyChild);\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.hash);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified InnerSpec message, length delimited. Does not implicitly {@link ics23.InnerSpec.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {ics23.IInnerSpec} message InnerSpec message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        InnerSpec.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes an InnerSpec message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.InnerSpec} InnerSpec\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        InnerSpec.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.InnerSpec();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.childOrder && message.childOrder.length))\n                        message.childOrder = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.childOrder.push(reader.int32());\n                    } else\n                        message.childOrder.push(reader.int32());\n                    break;\n                case 2:\n                    message.childSize = reader.int32();\n                    break;\n                case 3:\n                    message.minPrefixLength = reader.int32();\n                    break;\n                case 4:\n                    message.maxPrefixLength = reader.int32();\n                    break;\n                case 5:\n                    message.emptyChild = reader.bytes();\n                    break;\n                case 6:\n                    message.hash = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes an InnerSpec message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.InnerSpec} InnerSpec\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        InnerSpec.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies an InnerSpec message.\n         * @function verify\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        InnerSpec.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.childOrder != null && message.hasOwnProperty(\"childOrder\")) {\n                if (!Array.isArray(message.childOrder))\n                    return \"childOrder: array expected\";\n                for (var i = 0; i < message.childOrder.length; ++i)\n                    if (!$util.isInteger(message.childOrder[i]))\n                        return \"childOrder: integer[] expected\";\n            }\n            if (message.childSize != null && message.hasOwnProperty(\"childSize\"))\n                if (!$util.isInteger(message.childSize))\n                    return \"childSize: integer expected\";\n            if (message.minPrefixLength != null && message.hasOwnProperty(\"minPrefixLength\"))\n                if (!$util.isInteger(message.minPrefixLength))\n                    return \"minPrefixLength: integer expected\";\n            if (message.maxPrefixLength != null && message.hasOwnProperty(\"maxPrefixLength\"))\n                if (!$util.isInteger(message.maxPrefixLength))\n                    return \"maxPrefixLength: integer expected\";\n            if (message.emptyChild != null && message.hasOwnProperty(\"emptyChild\"))\n                if (!(message.emptyChild && typeof message.emptyChild.length === \"number\" || $util.isString(message.emptyChild)))\n                    return \"emptyChild: buffer expected\";\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                switch (message.hash) {\n                default:\n                    return \"hash: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            return null;\n        };\n\n        /**\n         * Creates an InnerSpec message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.InnerSpec} InnerSpec\n         */\n        InnerSpec.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.InnerSpec)\n                return object;\n            var message = new $root.ics23.InnerSpec();\n            if (object.childOrder) {\n                if (!Array.isArray(object.childOrder))\n                    throw TypeError(\".ics23.InnerSpec.childOrder: array expected\");\n                message.childOrder = [];\n                for (var i = 0; i < object.childOrder.length; ++i)\n                    message.childOrder[i] = object.childOrder[i] | 0;\n            }\n            if (object.childSize != null)\n                message.childSize = object.childSize | 0;\n            if (object.minPrefixLength != null)\n                message.minPrefixLength = object.minPrefixLength | 0;\n            if (object.maxPrefixLength != null)\n                message.maxPrefixLength = object.maxPrefixLength | 0;\n            if (object.emptyChild != null)\n                if (typeof object.emptyChild === \"string\")\n                    $util.base64.decode(object.emptyChild, message.emptyChild = $util.newBuffer($util.base64.length(object.emptyChild)), 0);\n                else if (object.emptyChild.length)\n                    message.emptyChild = object.emptyChild;\n            switch (object.hash) {\n            case \"NO_HASH\":\n            case 0:\n                message.hash = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.hash = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.hash = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.hash = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.hash = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.hash = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.hash = 6;\n                break;\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from an InnerSpec message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {ics23.InnerSpec} message InnerSpec\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        InnerSpec.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.childOrder = [];\n            if (options.defaults) {\n                object.childSize = 0;\n                object.minPrefixLength = 0;\n                object.maxPrefixLength = 0;\n                if (options.bytes === String)\n                    object.emptyChild = \"\";\n                else {\n                    object.emptyChild = [];\n                    if (options.bytes !== Array)\n                        object.emptyChild = $util.newBuffer(object.emptyChild);\n                }\n                object.hash = options.enums === String ? \"NO_HASH\" : 0;\n            }\n            if (message.childOrder && message.childOrder.length) {\n                object.childOrder = [];\n                for (var j = 0; j < message.childOrder.length; ++j)\n                    object.childOrder[j] = message.childOrder[j];\n            }\n            if (message.childSize != null && message.hasOwnProperty(\"childSize\"))\n                object.childSize = message.childSize;\n            if (message.minPrefixLength != null && message.hasOwnProperty(\"minPrefixLength\"))\n                object.minPrefixLength = message.minPrefixLength;\n            if (message.maxPrefixLength != null && message.hasOwnProperty(\"maxPrefixLength\"))\n                object.maxPrefixLength = message.maxPrefixLength;\n            if (message.emptyChild != null && message.hasOwnProperty(\"emptyChild\"))\n                object.emptyChild = options.bytes === String ? $util.base64.encode(message.emptyChild, 0, message.emptyChild.length) : options.bytes === Array ? Array.prototype.slice.call(message.emptyChild) : message.emptyChild;\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;\n            return object;\n        };\n\n        /**\n         * Converts this InnerSpec to JSON.\n         * @function toJSON\n         * @memberof ics23.InnerSpec\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        InnerSpec.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return InnerSpec;\n    })();\n\n    ics23.BatchProof = (function() {\n\n        /**\n         * Properties of a BatchProof.\n         * @memberof ics23\n         * @interface IBatchProof\n         * @property {Array.<ics23.IBatchEntry>|null} [entries] BatchProof entries\n         */\n\n        /**\n         * Constructs a new BatchProof.\n         * @memberof ics23\n         * @classdesc Represents a BatchProof.\n         * @implements IBatchProof\n         * @constructor\n         * @param {ics23.IBatchProof=} [properties] Properties to set\n         */\n        function BatchProof(properties) {\n            this.entries = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * BatchProof entries.\n         * @member {Array.<ics23.IBatchEntry>} entries\n         * @memberof ics23.BatchProof\n         * @instance\n         */\n        BatchProof.prototype.entries = $util.emptyArray;\n\n        /**\n         * Creates a new BatchProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {ics23.IBatchProof=} [properties] Properties to set\n         * @returns {ics23.BatchProof} BatchProof instance\n         */\n        BatchProof.create = function create(properties) {\n            return new BatchProof(properties);\n        };\n\n        /**\n         * Encodes the specified BatchProof message. Does not implicitly {@link ics23.BatchProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {ics23.IBatchProof} message BatchProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BatchProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.entries != null && message.entries.length)\n                for (var i = 0; i < message.entries.length; ++i)\n                    $root.ics23.BatchEntry.encode(message.entries[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified BatchProof message, length delimited. Does not implicitly {@link ics23.BatchProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {ics23.IBatchProof} message BatchProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BatchProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a BatchProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.BatchProof} BatchProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BatchProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.BatchProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.entries && message.entries.length))\n                        message.entries = [];\n                    message.entries.push($root.ics23.BatchEntry.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a BatchProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.BatchProof} BatchProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BatchProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a BatchProof message.\n         * @function verify\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        BatchProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.entries != null && message.hasOwnProperty(\"entries\")) {\n                if (!Array.isArray(message.entries))\n                    return \"entries: array expected\";\n                for (var i = 0; i < message.entries.length; ++i) {\n                    var error = $root.ics23.BatchEntry.verify(message.entries[i]);\n                    if (error)\n                        return \"entries.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a BatchProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.BatchProof} BatchProof\n         */\n        BatchProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.BatchProof)\n                return object;\n            var message = new $root.ics23.BatchProof();\n            if (object.entries) {\n                if (!Array.isArray(object.entries))\n                    throw TypeError(\".ics23.BatchProof.entries: array expected\");\n                message.entries = [];\n                for (var i = 0; i < object.entries.length; ++i) {\n                    if (typeof object.entries[i] !== \"object\")\n                        throw TypeError(\".ics23.BatchProof.entries: object expected\");\n                    message.entries[i] = $root.ics23.BatchEntry.fromObject(object.entries[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a BatchProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {ics23.BatchProof} message BatchProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        BatchProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.entries = [];\n            if (message.entries && message.entries.length) {\n                object.entries = [];\n                for (var j = 0; j < message.entries.length; ++j)\n                    object.entries[j] = $root.ics23.BatchEntry.toObject(message.entries[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this BatchProof to JSON.\n         * @function toJSON\n         * @memberof ics23.BatchProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        BatchProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BatchProof;\n    })();\n\n    ics23.BatchEntry = (function() {\n\n        /**\n         * Properties of a BatchEntry.\n         * @memberof ics23\n         * @interface IBatchEntry\n         * @property {ics23.IExistenceProof|null} [exist] BatchEntry exist\n         * @property {ics23.INonExistenceProof|null} [nonexist] BatchEntry nonexist\n         */\n\n        /**\n         * Constructs a new BatchEntry.\n         * @memberof ics23\n         * @classdesc Represents a BatchEntry.\n         * @implements IBatchEntry\n         * @constructor\n         * @param {ics23.IBatchEntry=} [properties] Properties to set\n         */\n        function BatchEntry(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * BatchEntry exist.\n         * @member {ics23.IExistenceProof|null|undefined} exist\n         * @memberof ics23.BatchEntry\n         * @instance\n         */\n        BatchEntry.prototype.exist = null;\n\n        /**\n         * BatchEntry nonexist.\n         * @member {ics23.INonExistenceProof|null|undefined} nonexist\n         * @memberof ics23.BatchEntry\n         * @instance\n         */\n        BatchEntry.prototype.nonexist = null;\n\n        // OneOf field names bound to virtual getters and setters\n        var $oneOfFields;\n\n        /**\n         * BatchEntry proof.\n         * @member {\"exist\"|\"nonexist\"|undefined} proof\n         * @memberof ics23.BatchEntry\n         * @instance\n         */\n        Object.defineProperty(BatchEntry.prototype, \"proof\", {\n            get: $util.oneOfGetter($oneOfFields = [\"exist\", \"nonexist\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Creates a new BatchEntry instance using the specified properties.\n         * @function create\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {ics23.IBatchEntry=} [properties] Properties to set\n         * @returns {ics23.BatchEntry} BatchEntry instance\n         */\n        BatchEntry.create = function create(properties) {\n            return new BatchEntry(properties);\n        };\n\n        /**\n         * Encodes the specified BatchEntry message. Does not implicitly {@link ics23.BatchEntry.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {ics23.IBatchEntry} message BatchEntry message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BatchEntry.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.exist != null && message.hasOwnProperty(\"exist\"))\n                $root.ics23.ExistenceProof.encode(message.exist, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\"))\n                $root.ics23.NonExistenceProof.encode(message.nonexist, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified BatchEntry message, length delimited. Does not implicitly {@link ics23.BatchEntry.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {ics23.IBatchEntry} message BatchEntry message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BatchEntry.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a BatchEntry message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.BatchEntry} BatchEntry\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BatchEntry.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.BatchEntry();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.exist = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.nonexist = $root.ics23.NonExistenceProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a BatchEntry message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.BatchEntry} BatchEntry\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BatchEntry.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a BatchEntry message.\n         * @function verify\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        BatchEntry.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            var properties = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.ExistenceProof.verify(message.exist);\n                    if (error)\n                        return \"exist.\" + error;\n                }\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.NonExistenceProof.verify(message.nonexist);\n                    if (error)\n                        return \"nonexist.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a BatchEntry message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.BatchEntry} BatchEntry\n         */\n        BatchEntry.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.BatchEntry)\n                return object;\n            var message = new $root.ics23.BatchEntry();\n            if (object.exist != null) {\n                if (typeof object.exist !== \"object\")\n                    throw TypeError(\".ics23.BatchEntry.exist: object expected\");\n                message.exist = $root.ics23.ExistenceProof.fromObject(object.exist);\n            }\n            if (object.nonexist != null) {\n                if (typeof object.nonexist !== \"object\")\n                    throw TypeError(\".ics23.BatchEntry.nonexist: object expected\");\n                message.nonexist = $root.ics23.NonExistenceProof.fromObject(object.nonexist);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a BatchEntry message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {ics23.BatchEntry} message BatchEntry\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        BatchEntry.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                object.exist = $root.ics23.ExistenceProof.toObject(message.exist, options);\n                if (options.oneofs)\n                    object.proof = \"exist\";\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                object.nonexist = $root.ics23.NonExistenceProof.toObject(message.nonexist, options);\n                if (options.oneofs)\n                    object.proof = \"nonexist\";\n            }\n            return object;\n        };\n\n        /**\n         * Converts this BatchEntry to JSON.\n         * @function toJSON\n         * @memberof ics23.BatchEntry\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        BatchEntry.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BatchEntry;\n    })();\n\n    ics23.CompressedBatchProof = (function() {\n\n        /**\n         * Properties of a CompressedBatchProof.\n         * @memberof ics23\n         * @interface ICompressedBatchProof\n         * @property {Array.<ics23.ICompressedBatchEntry>|null} [entries] CompressedBatchProof entries\n         * @property {Array.<ics23.IInnerOp>|null} [lookupInners] CompressedBatchProof lookupInners\n         */\n\n        /**\n         * Constructs a new CompressedBatchProof.\n         * @memberof ics23\n         * @classdesc Represents a CompressedBatchProof.\n         * @implements ICompressedBatchProof\n         * @constructor\n         * @param {ics23.ICompressedBatchProof=} [properties] Properties to set\n         */\n        function CompressedBatchProof(properties) {\n            this.entries = [];\n            this.lookupInners = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CompressedBatchProof entries.\n         * @member {Array.<ics23.ICompressedBatchEntry>} entries\n         * @memberof ics23.CompressedBatchProof\n         * @instance\n         */\n        CompressedBatchProof.prototype.entries = $util.emptyArray;\n\n        /**\n         * CompressedBatchProof lookupInners.\n         * @member {Array.<ics23.IInnerOp>} lookupInners\n         * @memberof ics23.CompressedBatchProof\n         * @instance\n         */\n        CompressedBatchProof.prototype.lookupInners = $util.emptyArray;\n\n        /**\n         * Creates a new CompressedBatchProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {ics23.ICompressedBatchProof=} [properties] Properties to set\n         * @returns {ics23.CompressedBatchProof} CompressedBatchProof instance\n         */\n        CompressedBatchProof.create = function create(properties) {\n            return new CompressedBatchProof(properties);\n        };\n\n        /**\n         * Encodes the specified CompressedBatchProof message. Does not implicitly {@link ics23.CompressedBatchProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {ics23.ICompressedBatchProof} message CompressedBatchProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedBatchProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.entries != null && message.entries.length)\n                for (var i = 0; i < message.entries.length; ++i)\n                    $root.ics23.CompressedBatchEntry.encode(message.entries[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.lookupInners != null && message.lookupInners.length)\n                for (var i = 0; i < message.lookupInners.length; ++i)\n                    $root.ics23.InnerOp.encode(message.lookupInners[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CompressedBatchProof message, length delimited. Does not implicitly {@link ics23.CompressedBatchProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {ics23.ICompressedBatchProof} message CompressedBatchProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedBatchProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CompressedBatchProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CompressedBatchProof} CompressedBatchProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedBatchProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CompressedBatchProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.entries && message.entries.length))\n                        message.entries = [];\n                    message.entries.push($root.ics23.CompressedBatchEntry.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    if (!(message.lookupInners && message.lookupInners.length))\n                        message.lookupInners = [];\n                    message.lookupInners.push($root.ics23.InnerOp.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CompressedBatchProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CompressedBatchProof} CompressedBatchProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedBatchProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CompressedBatchProof message.\n         * @function verify\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CompressedBatchProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.entries != null && message.hasOwnProperty(\"entries\")) {\n                if (!Array.isArray(message.entries))\n                    return \"entries: array expected\";\n                for (var i = 0; i < message.entries.length; ++i) {\n                    var error = $root.ics23.CompressedBatchEntry.verify(message.entries[i]);\n                    if (error)\n                        return \"entries.\" + error;\n                }\n            }\n            if (message.lookupInners != null && message.hasOwnProperty(\"lookupInners\")) {\n                if (!Array.isArray(message.lookupInners))\n                    return \"lookupInners: array expected\";\n                for (var i = 0; i < message.lookupInners.length; ++i) {\n                    var error = $root.ics23.InnerOp.verify(message.lookupInners[i]);\n                    if (error)\n                        return \"lookupInners.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CompressedBatchProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CompressedBatchProof} CompressedBatchProof\n         */\n        CompressedBatchProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CompressedBatchProof)\n                return object;\n            var message = new $root.ics23.CompressedBatchProof();\n            if (object.entries) {\n                if (!Array.isArray(object.entries))\n                    throw TypeError(\".ics23.CompressedBatchProof.entries: array expected\");\n                message.entries = [];\n                for (var i = 0; i < object.entries.length; ++i) {\n                    if (typeof object.entries[i] !== \"object\")\n                        throw TypeError(\".ics23.CompressedBatchProof.entries: object expected\");\n                    message.entries[i] = $root.ics23.CompressedBatchEntry.fromObject(object.entries[i]);\n                }\n            }\n            if (object.lookupInners) {\n                if (!Array.isArray(object.lookupInners))\n                    throw TypeError(\".ics23.CompressedBatchProof.lookupInners: array expected\");\n                message.lookupInners = [];\n                for (var i = 0; i < object.lookupInners.length; ++i) {\n                    if (typeof object.lookupInners[i] !== \"object\")\n                        throw TypeError(\".ics23.CompressedBatchProof.lookupInners: object expected\");\n                    message.lookupInners[i] = $root.ics23.InnerOp.fromObject(object.lookupInners[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CompressedBatchProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {ics23.CompressedBatchProof} message CompressedBatchProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CompressedBatchProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults) {\n                object.entries = [];\n                object.lookupInners = [];\n            }\n            if (message.entries && message.entries.length) {\n                object.entries = [];\n                for (var j = 0; j < message.entries.length; ++j)\n                    object.entries[j] = $root.ics23.CompressedBatchEntry.toObject(message.entries[j], options);\n            }\n            if (message.lookupInners && message.lookupInners.length) {\n                object.lookupInners = [];\n                for (var j = 0; j < message.lookupInners.length; ++j)\n                    object.lookupInners[j] = $root.ics23.InnerOp.toObject(message.lookupInners[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this CompressedBatchProof to JSON.\n         * @function toJSON\n         * @memberof ics23.CompressedBatchProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CompressedBatchProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CompressedBatchProof;\n    })();\n\n    ics23.CompressedBatchEntry = (function() {\n\n        /**\n         * Properties of a CompressedBatchEntry.\n         * @memberof ics23\n         * @interface ICompressedBatchEntry\n         * @property {ics23.ICompressedExistenceProof|null} [exist] CompressedBatchEntry exist\n         * @property {ics23.ICompressedNonExistenceProof|null} [nonexist] CompressedBatchEntry nonexist\n         */\n\n        /**\n         * Constructs a new CompressedBatchEntry.\n         * @memberof ics23\n         * @classdesc Represents a CompressedBatchEntry.\n         * @implements ICompressedBatchEntry\n         * @constructor\n         * @param {ics23.ICompressedBatchEntry=} [properties] Properties to set\n         */\n        function CompressedBatchEntry(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CompressedBatchEntry exist.\n         * @member {ics23.ICompressedExistenceProof|null|undefined} exist\n         * @memberof ics23.CompressedBatchEntry\n         * @instance\n         */\n        CompressedBatchEntry.prototype.exist = null;\n\n        /**\n         * CompressedBatchEntry nonexist.\n         * @member {ics23.ICompressedNonExistenceProof|null|undefined} nonexist\n         * @memberof ics23.CompressedBatchEntry\n         * @instance\n         */\n        CompressedBatchEntry.prototype.nonexist = null;\n\n        // OneOf field names bound to virtual getters and setters\n        var $oneOfFields;\n\n        /**\n         * CompressedBatchEntry proof.\n         * @member {\"exist\"|\"nonexist\"|undefined} proof\n         * @memberof ics23.CompressedBatchEntry\n         * @instance\n         */\n        Object.defineProperty(CompressedBatchEntry.prototype, \"proof\", {\n            get: $util.oneOfGetter($oneOfFields = [\"exist\", \"nonexist\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Creates a new CompressedBatchEntry instance using the specified properties.\n         * @function create\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {ics23.ICompressedBatchEntry=} [properties] Properties to set\n         * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry instance\n         */\n        CompressedBatchEntry.create = function create(properties) {\n            return new CompressedBatchEntry(properties);\n        };\n\n        /**\n         * Encodes the specified CompressedBatchEntry message. Does not implicitly {@link ics23.CompressedBatchEntry.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {ics23.ICompressedBatchEntry} message CompressedBatchEntry message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedBatchEntry.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.exist != null && message.hasOwnProperty(\"exist\"))\n                $root.ics23.CompressedExistenceProof.encode(message.exist, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\"))\n                $root.ics23.CompressedNonExistenceProof.encode(message.nonexist, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CompressedBatchEntry message, length delimited. Does not implicitly {@link ics23.CompressedBatchEntry.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {ics23.ICompressedBatchEntry} message CompressedBatchEntry message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedBatchEntry.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CompressedBatchEntry message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedBatchEntry.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CompressedBatchEntry();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.exist = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.nonexist = $root.ics23.CompressedNonExistenceProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CompressedBatchEntry message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedBatchEntry.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CompressedBatchEntry message.\n         * @function verify\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CompressedBatchEntry.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            var properties = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.CompressedExistenceProof.verify(message.exist);\n                    if (error)\n                        return \"exist.\" + error;\n                }\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.CompressedNonExistenceProof.verify(message.nonexist);\n                    if (error)\n                        return \"nonexist.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CompressedBatchEntry message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry\n         */\n        CompressedBatchEntry.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CompressedBatchEntry)\n                return object;\n            var message = new $root.ics23.CompressedBatchEntry();\n            if (object.exist != null) {\n                if (typeof object.exist !== \"object\")\n                    throw TypeError(\".ics23.CompressedBatchEntry.exist: object expected\");\n                message.exist = $root.ics23.CompressedExistenceProof.fromObject(object.exist);\n            }\n            if (object.nonexist != null) {\n                if (typeof object.nonexist !== \"object\")\n                    throw TypeError(\".ics23.CompressedBatchEntry.nonexist: object expected\");\n                message.nonexist = $root.ics23.CompressedNonExistenceProof.fromObject(object.nonexist);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CompressedBatchEntry message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {ics23.CompressedBatchEntry} message CompressedBatchEntry\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CompressedBatchEntry.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                object.exist = $root.ics23.CompressedExistenceProof.toObject(message.exist, options);\n                if (options.oneofs)\n                    object.proof = \"exist\";\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                object.nonexist = $root.ics23.CompressedNonExistenceProof.toObject(message.nonexist, options);\n                if (options.oneofs)\n                    object.proof = \"nonexist\";\n            }\n            return object;\n        };\n\n        /**\n         * Converts this CompressedBatchEntry to JSON.\n         * @function toJSON\n         * @memberof ics23.CompressedBatchEntry\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CompressedBatchEntry.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CompressedBatchEntry;\n    })();\n\n    ics23.CompressedExistenceProof = (function() {\n\n        /**\n         * Properties of a CompressedExistenceProof.\n         * @memberof ics23\n         * @interface ICompressedExistenceProof\n         * @property {Uint8Array|null} [key] CompressedExistenceProof key\n         * @property {Uint8Array|null} [value] CompressedExistenceProof value\n         * @property {ics23.ILeafOp|null} [leaf] CompressedExistenceProof leaf\n         * @property {Array.<number>|null} [path] CompressedExistenceProof path\n         */\n\n        /**\n         * Constructs a new CompressedExistenceProof.\n         * @memberof ics23\n         * @classdesc Represents a CompressedExistenceProof.\n         * @implements ICompressedExistenceProof\n         * @constructor\n         * @param {ics23.ICompressedExistenceProof=} [properties] Properties to set\n         */\n        function CompressedExistenceProof(properties) {\n            this.path = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CompressedExistenceProof key.\n         * @member {Uint8Array} key\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         */\n        CompressedExistenceProof.prototype.key = $util.newBuffer([]);\n\n        /**\n         * CompressedExistenceProof value.\n         * @member {Uint8Array} value\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         */\n        CompressedExistenceProof.prototype.value = $util.newBuffer([]);\n\n        /**\n         * CompressedExistenceProof leaf.\n         * @member {ics23.ILeafOp|null|undefined} leaf\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         */\n        CompressedExistenceProof.prototype.leaf = null;\n\n        /**\n         * CompressedExistenceProof path.\n         * @member {Array.<number>} path\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         */\n        CompressedExistenceProof.prototype.path = $util.emptyArray;\n\n        /**\n         * Creates a new CompressedExistenceProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {ics23.ICompressedExistenceProof=} [properties] Properties to set\n         * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof instance\n         */\n        CompressedExistenceProof.create = function create(properties) {\n            return new CompressedExistenceProof(properties);\n        };\n\n        /**\n         * Encodes the specified CompressedExistenceProof message. Does not implicitly {@link ics23.CompressedExistenceProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {ics23.ICompressedExistenceProof} message CompressedExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedExistenceProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\"))\n                $root.ics23.LeafOp.encode(message.leaf, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.path != null && message.path.length) {\n                writer.uint32(/* id 4, wireType 2 =*/34).fork();\n                for (var i = 0; i < message.path.length; ++i)\n                    writer.int32(message.path[i]);\n                writer.ldelim();\n            }\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CompressedExistenceProof message, length delimited. Does not implicitly {@link ics23.CompressedExistenceProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {ics23.ICompressedExistenceProof} message CompressedExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CompressedExistenceProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedExistenceProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CompressedExistenceProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.value = reader.bytes();\n                    break;\n                case 3:\n                    message.leaf = $root.ics23.LeafOp.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    if (!(message.path && message.path.length))\n                        message.path = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.path.push(reader.int32());\n                    } else\n                        message.path.push(reader.int32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CompressedExistenceProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CompressedExistenceProof message.\n         * @function verify\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CompressedExistenceProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key)))\n                    return \"key: buffer expected\";\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                if (!(message.value && typeof message.value.length === \"number\" || $util.isString(message.value)))\n                    return \"value: buffer expected\";\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\")) {\n                var error = $root.ics23.LeafOp.verify(message.leaf);\n                if (error)\n                    return \"leaf.\" + error;\n            }\n            if (message.path != null && message.hasOwnProperty(\"path\")) {\n                if (!Array.isArray(message.path))\n                    return \"path: array expected\";\n                for (var i = 0; i < message.path.length; ++i)\n                    if (!$util.isInteger(message.path[i]))\n                        return \"path: integer[] expected\";\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CompressedExistenceProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof\n         */\n        CompressedExistenceProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CompressedExistenceProof)\n                return object;\n            var message = new $root.ics23.CompressedExistenceProof();\n            if (object.key != null)\n                if (typeof object.key === \"string\")\n                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);\n                else if (object.key.length)\n                    message.key = object.key;\n            if (object.value != null)\n                if (typeof object.value === \"string\")\n                    $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);\n                else if (object.value.length)\n                    message.value = object.value;\n            if (object.leaf != null) {\n                if (typeof object.leaf !== \"object\")\n                    throw TypeError(\".ics23.CompressedExistenceProof.leaf: object expected\");\n                message.leaf = $root.ics23.LeafOp.fromObject(object.leaf);\n            }\n            if (object.path) {\n                if (!Array.isArray(object.path))\n                    throw TypeError(\".ics23.CompressedExistenceProof.path: array expected\");\n                message.path = [];\n                for (var i = 0; i < object.path.length; ++i)\n                    message.path[i] = object.path[i] | 0;\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CompressedExistenceProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {ics23.CompressedExistenceProof} message CompressedExistenceProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CompressedExistenceProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.path = [];\n            if (options.defaults) {\n                if (options.bytes === String)\n                    object.key = \"\";\n                else {\n                    object.key = [];\n                    if (options.bytes !== Array)\n                        object.key = $util.newBuffer(object.key);\n                }\n                if (options.bytes === String)\n                    object.value = \"\";\n                else {\n                    object.value = [];\n                    if (options.bytes !== Array)\n                        object.value = $util.newBuffer(object.value);\n                }\n                object.leaf = null;\n            }\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\"))\n                object.leaf = $root.ics23.LeafOp.toObject(message.leaf, options);\n            if (message.path && message.path.length) {\n                object.path = [];\n                for (var j = 0; j < message.path.length; ++j)\n                    object.path[j] = message.path[j];\n            }\n            return object;\n        };\n\n        /**\n         * Converts this CompressedExistenceProof to JSON.\n         * @function toJSON\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CompressedExistenceProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CompressedExistenceProof;\n    })();\n\n    ics23.CompressedNonExistenceProof = (function() {\n\n        /**\n         * Properties of a CompressedNonExistenceProof.\n         * @memberof ics23\n         * @interface ICompressedNonExistenceProof\n         * @property {Uint8Array|null} [key] CompressedNonExistenceProof key\n         * @property {ics23.ICompressedExistenceProof|null} [left] CompressedNonExistenceProof left\n         * @property {ics23.ICompressedExistenceProof|null} [right] CompressedNonExistenceProof right\n         */\n\n        /**\n         * Constructs a new CompressedNonExistenceProof.\n         * @memberof ics23\n         * @classdesc Represents a CompressedNonExistenceProof.\n         * @implements ICompressedNonExistenceProof\n         * @constructor\n         * @param {ics23.ICompressedNonExistenceProof=} [properties] Properties to set\n         */\n        function CompressedNonExistenceProof(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CompressedNonExistenceProof key.\n         * @member {Uint8Array} key\n         * @memberof ics23.CompressedNonExistenceProof\n         * @instance\n         */\n        CompressedNonExistenceProof.prototype.key = $util.newBuffer([]);\n\n        /**\n         * CompressedNonExistenceProof left.\n         * @member {ics23.ICompressedExistenceProof|null|undefined} left\n         * @memberof ics23.CompressedNonExistenceProof\n         * @instance\n         */\n        CompressedNonExistenceProof.prototype.left = null;\n\n        /**\n         * CompressedNonExistenceProof right.\n         * @member {ics23.ICompressedExistenceProof|null|undefined} right\n         * @memberof ics23.CompressedNonExistenceProof\n         * @instance\n         */\n        CompressedNonExistenceProof.prototype.right = null;\n\n        /**\n         * Creates a new CompressedNonExistenceProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {ics23.ICompressedNonExistenceProof=} [properties] Properties to set\n         * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof instance\n         */\n        CompressedNonExistenceProof.create = function create(properties) {\n            return new CompressedNonExistenceProof(properties);\n        };\n\n        /**\n         * Encodes the specified CompressedNonExistenceProof message. Does not implicitly {@link ics23.CompressedNonExistenceProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {ics23.ICompressedNonExistenceProof} message CompressedNonExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedNonExistenceProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);\n            if (message.left != null && message.hasOwnProperty(\"left\"))\n                $root.ics23.CompressedExistenceProof.encode(message.left, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.right != null && message.hasOwnProperty(\"right\"))\n                $root.ics23.CompressedExistenceProof.encode(message.right, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CompressedNonExistenceProof message, length delimited. Does not implicitly {@link ics23.CompressedNonExistenceProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {ics23.ICompressedNonExistenceProof} message CompressedNonExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedNonExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CompressedNonExistenceProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedNonExistenceProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CompressedNonExistenceProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.left = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.right = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CompressedNonExistenceProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedNonExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CompressedNonExistenceProof message.\n         * @function verify\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CompressedNonExistenceProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key)))\n                    return \"key: buffer expected\";\n            if (message.left != null && message.hasOwnProperty(\"left\")) {\n                var error = $root.ics23.CompressedExistenceProof.verify(message.left);\n                if (error)\n                    return \"left.\" + error;\n            }\n            if (message.right != null && message.hasOwnProperty(\"right\")) {\n                var error = $root.ics23.CompressedExistenceProof.verify(message.right);\n                if (error)\n                    return \"right.\" + error;\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CompressedNonExistenceProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof\n         */\n        CompressedNonExistenceProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CompressedNonExistenceProof)\n                return object;\n            var message = new $root.ics23.CompressedNonExistenceProof();\n            if (object.key != null)\n                if (typeof object.key === \"string\")\n                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);\n                else if (object.key.length)\n                    message.key = object.key;\n            if (object.left != null) {\n                if (typeof object.left !== \"object\")\n                    throw TypeError(\".ics23.CompressedNonExistenceProof.left: object expected\");\n                message.left = $root.ics23.CompressedExistenceProof.fromObject(object.left);\n            }\n            if (object.right != null) {\n                if (typeof object.right !== \"object\")\n                    throw TypeError(\".ics23.CompressedNonExistenceProof.right: object expected\");\n                message.right = $root.ics23.CompressedExistenceProof.fromObject(object.right);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CompressedNonExistenceProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {ics23.CompressedNonExistenceProof} message CompressedNonExistenceProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CompressedNonExistenceProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                if (options.bytes === String)\n                    object.key = \"\";\n                else {\n                    object.key = [];\n                    if (options.bytes !== Array)\n                        object.key = $util.newBuffer(object.key);\n                }\n                object.left = null;\n                object.right = null;\n            }\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n            if (message.left != null && message.hasOwnProperty(\"left\"))\n                object.left = $root.ics23.CompressedExistenceProof.toObject(message.left, options);\n            if (message.right != null && message.hasOwnProperty(\"right\"))\n                object.right = $root.ics23.CompressedExistenceProof.toObject(message.right, options);\n            return object;\n        };\n\n        /**\n         * Converts this CompressedNonExistenceProof to JSON.\n         * @function toJSON\n         * @memberof ics23.CompressedNonExistenceProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CompressedNonExistenceProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CompressedNonExistenceProof;\n    })();\n\n    return ics23;\n})();\n\nmodule.exports = $root;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbmZpby9pY3MyMy9idWlsZC9nZW5lcmF0ZWQvY29kZWNpbXBsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ2E7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQW9COztBQUU1QztBQUNBOztBQUVBO0FBQ0EsMEVBQTBFOztBQUUxRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QyxzQkFBc0IsaUJBQWlCO0FBQ3ZDLHNCQUFzQixvQkFBb0I7QUFDMUMsc0JBQXNCLDZCQUE2QjtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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azovL29wZW4tcHJvLW5leHQvLi9ub2RlX21vZHVsZXMvQGNvbmZpby9pY3MyMy9idWlsZC9nZW5lcmF0ZWQvY29kZWNpbXBsLmpzP2NlMzYiXSwic291cmNlc0NvbnRlbnQiOlsiLyplc2xpbnQtZGlzYWJsZSBibG9jay1zY29wZWQtdmFyLCBpZC1sZW5ndGgsIG5vLWNvbnRyb2wtcmVnZXgsIG5vLW1hZ2ljLW51bWJlcnMsIG5vLXByb3RvdHlwZS1idWlsdGlucywgbm8tcmVkZWNsYXJlLCBuby1zaGFkb3csIG5vLXZhciwgc29ydC12YXJzKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJHByb3RvYnVmID0gcmVxdWlyZShcInByb3RvYnVmanMvbWluaW1hbFwiKTtcblxuLy8gQ29tbW9uIGFsaWFzZXNcbnZhciAkUmVhZGVyID0gJHByb3RvYnVmLlJlYWRlciwgJFdyaXRlciA9ICRwcm90b2J1Zi5Xcml0ZXIsICR1dGlsID0gJHByb3RvYnVmLnV0aWw7XG5cbi8vIEV4cG9ydGVkIHJvb3QgbmFtZXNwYWNlXG52YXIgJHJvb3QgPSAkcHJvdG9idWYucm9vdHNbXCJkZWZhdWx0XCJdIHx8ICgkcHJvdG9idWYucm9vdHNbXCJkZWZhdWx0XCJdID0ge30pO1xuXG4kcm9vdC5pY3MyMyA9IChmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIE5hbWVzcGFjZSBpY3MyMy5cbiAgICAgKiBAZXhwb3J0cyBpY3MyM1xuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKi9cbiAgICB2YXIgaWNzMjMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEhhc2hPcCBlbnVtLlxuICAgICAqIEBuYW1lIGljczIzLkhhc2hPcFxuICAgICAqIEBlbnVtIHtzdHJpbmd9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IE5PX0hBU0g9MCBOT19IQVNIIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFNIQTI1Nj0xIFNIQTI1NiB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTSEE1MTI9MiBTSEE1MTIgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gS0VDQ0FLPTMgS0VDQ0FLIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFJJUEVNRDE2MD00IFJJUEVNRDE2MCB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBCSVRDT0lOPTUgQklUQ09JTiB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTSEE1MTJfMjU2PTYgU0hBNTEyXzI1NiB2YWx1ZVxuICAgICAqL1xuICAgIGljczIzLkhhc2hPcCA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlc0J5SWQgPSB7fSwgdmFsdWVzID0gT2JqZWN0LmNyZWF0ZSh2YWx1ZXNCeUlkKTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMF0gPSBcIk5PX0hBU0hcIl0gPSAwO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxXSA9IFwiU0hBMjU2XCJdID0gMTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMl0gPSBcIlNIQTUxMlwiXSA9IDI7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzNdID0gXCJLRUNDQUtcIl0gPSAzO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs0XSA9IFwiUklQRU1EMTYwXCJdID0gNDtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNV0gPSBcIkJJVENPSU5cIl0gPSA1O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs2XSA9IFwiU0hBNTEyXzI1NlwiXSA9IDY7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfSkoKTtcblxuICAgIC8qKlxuICAgICAqIExlbmd0aE9wIGRlZmluZXMgaG93IHRvIHByb2Nlc3MgdGhlIGtleSBhbmQgdmFsdWUgb2YgdGhlIExlYWZPcFxuICAgICAqIHRvIGluY2x1ZGUgbGVuZ3RoIGluZm9ybWF0aW9uLiBBZnRlciBlbmNvZGluZyB0aGUgbGVuZ3RoIHdpdGggdGhlIGdpdmVuXG4gICAgICogYWxnb3JpdGhtLCB0aGUgbGVuZ3RoIHdpbGwgYmUgcHJlcGVuZGVkIHRvIHRoZSBrZXkgYW5kIHZhbHVlIGJ5dGVzLlxuICAgICAqIChFYWNoIG9uZSB3aXRoIGl0J3Mgb3duIGVuY29kZWQgbGVuZ3RoKVxuICAgICAqIEBuYW1lIGljczIzLkxlbmd0aE9wXG4gICAgICogQGVudW0ge3N0cmluZ31cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gTk9fUFJFRklYPTAgTk9fUFJFRklYIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFZBUl9QUk9UTz0xIFZBUl9QUk9UTyB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBWQVJfUkxQPTIgVkFSX1JMUCB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBGSVhFRDMyX0JJRz0zIEZJWEVEMzJfQklHIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEZJWEVEMzJfTElUVExFPTQgRklYRUQzMl9MSVRUTEUgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gRklYRUQ2NF9CSUc9NSBGSVhFRDY0X0JJRyB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBGSVhFRDY0X0xJVFRMRT02IEZJWEVENjRfTElUVExFIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFJFUVVJUkVfMzJfQllURVM9NyBSRVFVSVJFXzMyX0JZVEVTIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFJFUVVJUkVfNjRfQllURVM9OCBSRVFVSVJFXzY0X0JZVEVTIHZhbHVlXG4gICAgICovXG4gICAgaWNzMjMuTGVuZ3RoT3AgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZXNCeUlkID0ge30sIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzBdID0gXCJOT19QUkVGSVhcIl0gPSAwO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxXSA9IFwiVkFSX1BST1RPXCJdID0gMTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMl0gPSBcIlZBUl9STFBcIl0gPSAyO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFszXSA9IFwiRklYRUQzMl9CSUdcIl0gPSAzO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs0XSA9IFwiRklYRUQzMl9MSVRUTEVcIl0gPSA0O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs1XSA9IFwiRklYRUQ2NF9CSUdcIl0gPSA1O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs2XSA9IFwiRklYRUQ2NF9MSVRUTEVcIl0gPSA2O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs3XSA9IFwiUkVRVUlSRV8zMl9CWVRFU1wiXSA9IDc7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzhdID0gXCJSRVFVSVJFXzY0X0JZVEVTXCJdID0gODtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9KSgpO1xuXG4gICAgaWNzMjMuRXhpc3RlbmNlUHJvb2YgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYW4gRXhpc3RlbmNlUHJvb2YuXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyM1xuICAgICAgICAgKiBAaW50ZXJmYWNlIElFeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl8bnVsbH0gW2tleV0gRXhpc3RlbmNlUHJvb2Yga2V5XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7VWludDhBcnJheXxudWxsfSBbdmFsdWVdIEV4aXN0ZW5jZVByb29mIHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7aWNzMjMuSUxlYWZPcHxudWxsfSBbbGVhZl0gRXhpc3RlbmNlUHJvb2YgbGVhZlxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxpY3MyMy5JSW5uZXJPcD58bnVsbH0gW3BhdGhdIEV4aXN0ZW5jZVByb29mIHBhdGhcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgRXhpc3RlbmNlUHJvb2YuXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyM1xuICAgICAgICAgKiBAY2xhc3NkZXNjIEV4aXN0ZW5jZVByb29mIHRha2VzIGEga2V5IGFuZCBhIHZhbHVlIGFuZCBhIHNldCBvZiBzdGVwcyB0byBwZXJmb3JtIG9uIGl0LlxuICAgICAgICAgKiBUaGUgcmVzdWx0IG9mIHBlZm9ybWluZyBhbGwgdGhlc2Ugc3RlcHMgd2lsbCBwcm92aWRlIGEgXCJyb290IGhhc2hcIiwgd2hpY2ggY2FuXG4gICAgICAgICAqIGJlIGNvbXBhcmVkIHRvIHRoZSB2YWx1ZSBpbiBhIGhlYWRlci5cbiAgICAgICAgICogXG4gICAgICAgICAqIFNpbmNlIGl0IGlzIGNvbXB1dGF0aW9uYWxseSBpbmZlYXNpYmxlIHRvIHByb2R1Y2UgYSBoYXNoIGNvbGxpc3Npb24gZm9yIGFueSBvZiB0aGUgdXNlZFxuICAgICAgICAgKiBjcnlwdG9ncmFwaGljIGhhc2ggZnVuY3Rpb25zLCBpZiBzb21lb25lIGNhbiBwcm92aWRlIGEgc2VyaWVzIG9mIG9wZXJhdGlvbnMgdG8gdHJhbnNmb3JtXG4gICAgICAgICAqIGEgZ2l2ZW4ga2V5IGFuZCB2YWx1ZSBpbnRvIGEgcm9vdCBoYXNoIHRoYXQgbWF0Y2hlcyBzb21lIHRydXN0ZWQgcm9vdCwgdGhlc2Uga2V5IGFuZCB2YWx1ZXNcbiAgICAgICAgICogbXVzdCBiZSBpbiB0aGUgcmVmZXJlbmNlZCBtZXJrbGUgdHJlZS5cbiAgICAgICAgICogXG4gICAgICAgICAqIFRoZSBvbmx5IHBvc3NpYmxlIGlzc3VlIGlzIG1hbGlhYmxpdHkgaW4gTGVhZk9wLCBzdWNoIGFzIHByb3ZpZGluZyBleHRyYSBwcmVmaXggZGF0YSxcbiAgICAgICAgICogd2hpY2ggc2hvdWxkIGJlIGNvbnRyb2xsZWQgYnkgYSBzcGVjLiBFZy4gd2l0aCBsZW5ndGhPcCBhcyBOT05FLFxuICAgICAgICAgKiBwcmVmaXggPSBGT08sIGtleSA9IEJBUiwgdmFsdWUgPSBDSE9JQ0VcbiAgICAgICAgICogYW5kXG4gICAgICAgICAqIHByZWZpeCA9IEYsIGtleSA9IE9PQkFSLCB2YWx1ZSA9IENIT0lDRVxuICAgICAgICAgKiB3b3VsZCBwcm9kdWNlIHRoZSBzYW1lIHZhbHVlLlxuICAgICAgICAgKiBcbiAgICAgICAgICogV2l0aCBMZW5ndGhPcCB0aGlzIGlzIHRyaWNrZXIgYnV0IG5vdCBpbXBvc3NpYmxlLiBXaGljaCBpcyB3aHkgdGhlIFwibGVhZlByZWZpeEVxdWFsXCIgZmllbGRcbiAgICAgICAgICogaW4gdGhlIFByb29mU3BlYyBpcyB2YWx1YWJsZSB0byBwcmV2ZW50IHRoaXMgbXV0YWJpbGl0eS4gQW5kIHdoeSBhbGwgdHJlZXMgc2hvdWxkXG4gICAgICAgICAqIGxlbmd0aC1wcmVmaXggdGhlIGRhdGEgYmVmb3JlIGhhc2hpbmcgaXQuXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElFeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JRXhpc3RlbmNlUHJvb2Y9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEV4aXN0ZW5jZVByb29mKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IFtdO1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeGlzdGVuY2VQcm9vZiBrZXkuXG4gICAgICAgICAqIEBtZW1iZXIge1VpbnQ4QXJyYXl9IGtleVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBFeGlzdGVuY2VQcm9vZi5wcm90b3R5cGUua2V5ID0gJHV0aWwubmV3QnVmZmVyKFtdKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXhpc3RlbmNlUHJvb2YgdmFsdWUuXG4gICAgICAgICAqIEBtZW1iZXIge1VpbnQ4QXJyYXl9IHZhbHVlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEV4aXN0ZW5jZVByb29mLnByb3RvdHlwZS52YWx1ZSA9ICR1dGlsLm5ld0J1ZmZlcihbXSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4aXN0ZW5jZVByb29mIGxlYWYuXG4gICAgICAgICAqIEBtZW1iZXIge2ljczIzLklMZWFmT3B8bnVsbHx1bmRlZmluZWR9IGxlYWZcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgRXhpc3RlbmNlUHJvb2YucHJvdG90eXBlLmxlYWYgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeGlzdGVuY2VQcm9vZiBwYXRoLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48aWNzMjMuSUlubmVyT3A+fSBwYXRoXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEV4aXN0ZW5jZVByb29mLnByb3RvdHlwZS5wYXRoID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBFeGlzdGVuY2VQcm9vZiBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JRXhpc3RlbmNlUHJvb2Y9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge2ljczIzLkV4aXN0ZW5jZVByb29mfSBFeGlzdGVuY2VQcm9vZiBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgRXhpc3RlbmNlUHJvb2YuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXhpc3RlbmNlUHJvb2YocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBFeGlzdGVuY2VQcm9vZiBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBpY3MyMy5FeGlzdGVuY2VQcm9vZi52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklFeGlzdGVuY2VQcm9vZn0gbWVzc2FnZSBFeGlzdGVuY2VQcm9vZiBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIEV4aXN0ZW5jZVByb29mLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5rZXkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwia2V5XCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuYnl0ZXMobWVzc2FnZS5rZXkpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidmFsdWVcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLzE4KS5ieXRlcyhtZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmxlYWYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibGVhZlwiKSlcbiAgICAgICAgICAgICAgICAkcm9vdC5pY3MyMy5MZWFmT3AuZW5jb2RlKG1lc3NhZ2UubGVhZiwgd3JpdGVyLnVpbnQzMigvKiBpZCAzLCB3aXJlVHlwZSAyID0qLzI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucGF0aCAhPSBudWxsICYmIG1lc3NhZ2UucGF0aC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnBhdGgubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290LmljczIzLklubmVyT3AuZW5jb2RlKG1lc3NhZ2UucGF0aFtpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCA0LCB3aXJlVHlwZSAyID0qLzM0KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEV4aXN0ZW5jZVByb29mIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIGljczIzLkV4aXN0ZW5jZVByb29mLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSUV4aXN0ZW5jZVByb29mfSBtZXNzYWdlIEV4aXN0ZW5jZVByb29mIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgRXhpc3RlbmNlUHJvb2YuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYW4gRXhpc3RlbmNlUHJvb2YgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge2ljczIzLkV4aXN0ZW5jZVByb29mfSBFeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIEV4aXN0ZW5jZVByb29mLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmljczIzLkV4aXN0ZW5jZVByb29mKCk7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2V5ID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubGVhZiA9ICRyb290LmljczIzLkxlYWZPcC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UucGF0aCAmJiBtZXNzYWdlLnBhdGgubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGF0aCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBhdGgucHVzaCgkcm9vdC5pY3MyMy5Jbm5lck9wLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGFuIEV4aXN0ZW5jZVByb29mIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5FeGlzdGVuY2VQcm9vZn0gRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBFeGlzdGVuY2VQcm9vZi5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYW4gRXhpc3RlbmNlUHJvb2YgbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIEV4aXN0ZW5jZVByb29mLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmtleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJrZXlcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5rZXkgJiYgdHlwZW9mIG1lc3NhZ2Uua2V5Lmxlbmd0aCA9PT0gXCJudW1iZXJcIiB8fCAkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmtleSkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJrZXk6IGJ1ZmZlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidmFsdWVcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS52YWx1ZSAmJiB0eXBlb2YgbWVzc2FnZS52YWx1ZS5sZW5ndGggPT09IFwibnVtYmVyXCIgfHwgJHV0aWwuaXNTdHJpbmcobWVzc2FnZS52YWx1ZSkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZTogYnVmZmVyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5sZWFmICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImxlYWZcIikpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5pY3MyMy5MZWFmT3AudmVyaWZ5KG1lc3NhZ2UubGVhZik7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJsZWFmLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5wYXRoICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInBhdGhcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5wYXRoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicGF0aDogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UucGF0aC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5pY3MyMy5Jbm5lck9wLnZlcmlmeShtZXNzYWdlLnBhdGhbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJwYXRoLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gRXhpc3RlbmNlUHJvb2YgbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5FeGlzdGVuY2VQcm9vZn0gRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICovXG4gICAgICAgIEV4aXN0ZW5jZVByb29mLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmljczIzLkV4aXN0ZW5jZVByb29mKVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5pY3MyMy5FeGlzdGVuY2VQcm9vZigpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5rZXkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5rZXkgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICR1dGlsLmJhc2U2NC5kZWNvZGUob2JqZWN0LmtleSwgbWVzc2FnZS5rZXkgPSAkdXRpbC5uZXdCdWZmZXIoJHV0aWwuYmFzZTY0Lmxlbmd0aChvYmplY3Qua2V5KSksIDApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9iamVjdC5rZXkubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtleSA9IG9iamVjdC5rZXk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnZhbHVlICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudmFsdWUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICR1dGlsLmJhc2U2NC5kZWNvZGUob2JqZWN0LnZhbHVlLCBtZXNzYWdlLnZhbHVlID0gJHV0aWwubmV3QnVmZmVyKCR1dGlsLmJhc2U2NC5sZW5ndGgob2JqZWN0LnZhbHVlKSksIDApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9iamVjdC52YWx1ZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWUgPSBvYmplY3QudmFsdWU7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmxlYWYgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmxlYWYgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5pY3MyMy5FeGlzdGVuY2VQcm9vZi5sZWFmOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5sZWFmID0gJHJvb3QuaWNzMjMuTGVhZk9wLmZyb21PYmplY3Qob2JqZWN0LmxlYWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5wYXRoKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmljczIzLkV4aXN0ZW5jZVByb29mLnBhdGg6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UucGF0aCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnBhdGgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QucGF0aFtpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5pY3MyMy5FeGlzdGVuY2VQcm9vZi5wYXRoOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGF0aFtpXSA9ICRyb290LmljczIzLklubmVyT3AuZnJvbU9iamVjdChvYmplY3QucGF0aFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhbiBFeGlzdGVuY2VQcm9vZiBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLkV4aXN0ZW5jZVByb29mfSBtZXNzYWdlIEV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgRXhpc3RlbmNlUHJvb2YudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnBhdGggPSBbXTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZylcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmtleSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5rZXkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZXMgIT09IEFycmF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmtleSA9ICR1dGlsLm5ld0J1ZmZlcihvYmplY3Qua2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZylcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzICE9PSBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9ICR1dGlsLm5ld0J1ZmZlcihvYmplY3QudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmplY3QubGVhZiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5rZXkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwia2V5XCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5rZXkgPSBvcHRpb25zLmJ5dGVzID09PSBTdHJpbmcgPyAkdXRpbC5iYXNlNjQuZW5jb2RlKG1lc3NhZ2Uua2V5LCAwLCBtZXNzYWdlLmtleS5sZW5ndGgpIDogb3B0aW9ucy5ieXRlcyA9PT0gQXJyYXkgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZXNzYWdlLmtleSkgOiBtZXNzYWdlLmtleTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZyA/ICR1dGlsLmJhc2U2NC5lbmNvZGUobWVzc2FnZS52YWx1ZSwgMCwgbWVzc2FnZS52YWx1ZS5sZW5ndGgpIDogb3B0aW9ucy5ieXRlcyA9PT0gQXJyYXkgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZXNzYWdlLnZhbHVlKSA6IG1lc3NhZ2UudmFsdWU7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5sZWFmICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImxlYWZcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmxlYWYgPSAkcm9vdC5pY3MyMy5MZWFmT3AudG9PYmplY3QobWVzc2FnZS5sZWFmLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnBhdGggJiYgbWVzc2FnZS5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5wYXRoID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnBhdGgubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5wYXRoW2pdID0gJHJvb3QuaWNzMjMuSW5uZXJPcC50b09iamVjdChtZXNzYWdlLnBhdGhbal0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBFeGlzdGVuY2VQcm9vZiB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgRXhpc3RlbmNlUHJvb2YucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBFeGlzdGVuY2VQcm9vZjtcbiAgICB9KSgpO1xuXG4gICAgaWNzMjMuTm9uRXhpc3RlbmNlUHJvb2YgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBOb25FeGlzdGVuY2VQcm9vZi5cbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzXG4gICAgICAgICAqIEBpbnRlcmZhY2UgSU5vbkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7VWludDhBcnJheXxudWxsfSBba2V5XSBOb25FeGlzdGVuY2VQcm9vZiBrZXlcbiAgICAgICAgICogQHByb3BlcnR5IHtpY3MyMy5JRXhpc3RlbmNlUHJvb2Z8bnVsbH0gW2xlZnRdIE5vbkV4aXN0ZW5jZVByb29mIGxlZnRcbiAgICAgICAgICogQHByb3BlcnR5IHtpY3MyMy5JRXhpc3RlbmNlUHJvb2Z8bnVsbH0gW3JpZ2h0XSBOb25FeGlzdGVuY2VQcm9vZiByaWdodFxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBOb25FeGlzdGVuY2VQcm9vZi5cbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzXG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIE5vbkV4aXN0ZW5jZVByb29mLlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJTm9uRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSU5vbkV4aXN0ZW5jZVByb29mPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBOb25FeGlzdGVuY2VQcm9vZihwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbkV4aXN0ZW5jZVByb29mIGtleS5cbiAgICAgICAgICogQG1lbWJlciB7VWludDhBcnJheX0ga2V5XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Ob25FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIE5vbkV4aXN0ZW5jZVByb29mLnByb3RvdHlwZS5rZXkgPSAkdXRpbC5uZXdCdWZmZXIoW10pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb25FeGlzdGVuY2VQcm9vZiBsZWZ0LlxuICAgICAgICAgKiBAbWVtYmVyIHtpY3MyMy5JRXhpc3RlbmNlUHJvb2Z8bnVsbHx1bmRlZmluZWR9IGxlZnRcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLk5vbkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTm9uRXhpc3RlbmNlUHJvb2YucHJvdG90eXBlLmxlZnQgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb25FeGlzdGVuY2VQcm9vZiByaWdodC5cbiAgICAgICAgICogQG1lbWJlciB7aWNzMjMuSUV4aXN0ZW5jZVByb29mfG51bGx8dW5kZWZpbmVkfSByaWdodFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuTm9uRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBOb25FeGlzdGVuY2VQcm9vZi5wcm90b3R5cGUucmlnaHQgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IE5vbkV4aXN0ZW5jZVByb29mIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuTm9uRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklOb25FeGlzdGVuY2VQcm9vZj19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuTm9uRXhpc3RlbmNlUHJvb2Z9IE5vbkV4aXN0ZW5jZVByb29mIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBOb25FeGlzdGVuY2VQcm9vZi5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOb25FeGlzdGVuY2VQcm9vZihwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIE5vbkV4aXN0ZW5jZVByb29mIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIGljczIzLk5vbkV4aXN0ZW5jZVByb29mLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Ob25FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSU5vbkV4aXN0ZW5jZVByb29mfSBtZXNzYWdlIE5vbkV4aXN0ZW5jZVByb29mIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgTm9uRXhpc3RlbmNlUHJvb2YuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmtleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJrZXlcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLzEwKS5ieXRlcyhtZXNzYWdlLmtleSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5sZWZ0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImxlZnRcIikpXG4gICAgICAgICAgICAgICAgJHJvb3QuaWNzMjMuRXhpc3RlbmNlUHJvb2YuZW5jb2RlKG1lc3NhZ2UubGVmdCwgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLzE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucmlnaHQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicmlnaHRcIikpXG4gICAgICAgICAgICAgICAgJHJvb3QuaWNzMjMuRXhpc3RlbmNlUHJvb2YuZW5jb2RlKG1lc3NhZ2UucmlnaHQsIHdyaXRlci51aW50MzIoLyogaWQgMywgd2lyZVR5cGUgMiA9Ki8yNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBOb25FeGlzdGVuY2VQcm9vZiBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBpY3MyMy5Ob25FeGlzdGVuY2VQcm9vZi52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuTm9uRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklOb25FeGlzdGVuY2VQcm9vZn0gbWVzc2FnZSBOb25FeGlzdGVuY2VQcm9vZiBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIE5vbkV4aXN0ZW5jZVByb29mLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgTm9uRXhpc3RlbmNlUHJvb2YgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuTm9uRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge2ljczIzLk5vbkV4aXN0ZW5jZVByb29mfSBOb25FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIE5vbkV4aXN0ZW5jZVByb29mLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmljczIzLk5vbkV4aXN0ZW5jZVByb29mKCk7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2V5ID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5sZWZ0ID0gJHJvb3QuaWNzMjMuRXhpc3RlbmNlUHJvb2YuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJpZ2h0ID0gJHJvb3QuaWNzMjMuRXhpc3RlbmNlUHJvb2YuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIE5vbkV4aXN0ZW5jZVByb29mIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLk5vbkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5Ob25FeGlzdGVuY2VQcm9vZn0gTm9uRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBOb25FeGlzdGVuY2VQcm9vZi5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYSBOb25FeGlzdGVuY2VQcm9vZiBtZXNzYWdlLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Ob25FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgTm9uRXhpc3RlbmNlUHJvb2YudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uua2V5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmtleSAmJiB0eXBlb2YgbWVzc2FnZS5rZXkubGVuZ3RoID09PSBcIm51bWJlclwiIHx8ICR1dGlsLmlzU3RyaW5nKG1lc3NhZ2Uua2V5KSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImtleTogYnVmZmVyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5sZWZ0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImxlZnRcIikpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5pY3MyMy5FeGlzdGVuY2VQcm9vZi52ZXJpZnkobWVzc2FnZS5sZWZ0KTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxlZnQuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnJpZ2h0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInJpZ2h0XCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuaWNzMjMuRXhpc3RlbmNlUHJvb2YudmVyaWZ5KG1lc3NhZ2UucmlnaHQpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicmlnaHQuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgTm9uRXhpc3RlbmNlUHJvb2YgbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuTm9uRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5Ob25FeGlzdGVuY2VQcm9vZn0gTm9uRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICovXG4gICAgICAgIE5vbkV4aXN0ZW5jZVByb29mLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmljczIzLk5vbkV4aXN0ZW5jZVByb29mKVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5pY3MyMy5Ob25FeGlzdGVuY2VQcm9vZigpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5rZXkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5rZXkgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICR1dGlsLmJhc2U2NC5kZWNvZGUob2JqZWN0LmtleSwgbWVzc2FnZS5rZXkgPSAkdXRpbC5uZXdCdWZmZXIoJHV0aWwuYmFzZTY0Lmxlbmd0aChvYmplY3Qua2V5KSksIDApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9iamVjdC5rZXkubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtleSA9IG9iamVjdC5rZXk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmxlZnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmxlZnQgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5pY3MyMy5Ob25FeGlzdGVuY2VQcm9vZi5sZWZ0OiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5sZWZ0ID0gJHJvb3QuaWNzMjMuRXhpc3RlbmNlUHJvb2YuZnJvbU9iamVjdChvYmplY3QubGVmdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LnJpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5yaWdodCAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmljczIzLk5vbkV4aXN0ZW5jZVByb29mLnJpZ2h0OiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5yaWdodCA9ICRyb290LmljczIzLkV4aXN0ZW5jZVByb29mLmZyb21PYmplY3Qob2JqZWN0LnJpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBOb25FeGlzdGVuY2VQcm9vZiBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuTm9uRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLk5vbkV4aXN0ZW5jZVByb29mfSBtZXNzYWdlIE5vbkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgTm9uRXhpc3RlbmNlUHJvb2YudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3Qua2V5ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmtleSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieXRlcyAhPT0gQXJyYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Qua2V5ID0gJHV0aWwubmV3QnVmZmVyKG9iamVjdC5rZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmplY3QubGVmdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnJpZ2h0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmtleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJrZXlcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmtleSA9IG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZyA/ICR1dGlsLmJhc2U2NC5lbmNvZGUobWVzc2FnZS5rZXksIDAsIG1lc3NhZ2Uua2V5Lmxlbmd0aCkgOiBvcHRpb25zLmJ5dGVzID09PSBBcnJheSA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG1lc3NhZ2Uua2V5KSA6IG1lc3NhZ2Uua2V5O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubGVmdCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJsZWZ0XCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5sZWZ0ID0gJHJvb3QuaWNzMjMuRXhpc3RlbmNlUHJvb2YudG9PYmplY3QobWVzc2FnZS5sZWZ0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnJpZ2h0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInJpZ2h0XCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5yaWdodCA9ICRyb290LmljczIzLkV4aXN0ZW5jZVByb29mLnRvT2JqZWN0KG1lc3NhZ2UucmlnaHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBOb25FeGlzdGVuY2VQcm9vZiB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Ob25FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgTm9uRXhpc3RlbmNlUHJvb2YucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBOb25FeGlzdGVuY2VQcm9vZjtcbiAgICB9KSgpO1xuXG4gICAgaWNzMjMuQ29tbWl0bWVudFByb29mID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgQ29tbWl0bWVudFByb29mLlxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjNcbiAgICAgICAgICogQGludGVyZmFjZSBJQ29tbWl0bWVudFByb29mXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7aWNzMjMuSUV4aXN0ZW5jZVByb29mfG51bGx9IFtleGlzdF0gQ29tbWl0bWVudFByb29mIGV4aXN0XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7aWNzMjMuSU5vbkV4aXN0ZW5jZVByb29mfG51bGx9IFtub25leGlzdF0gQ29tbWl0bWVudFByb29mIG5vbmV4aXN0XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7aWNzMjMuSUJhdGNoUHJvb2Z8bnVsbH0gW2JhdGNoXSBDb21taXRtZW50UHJvb2YgYmF0Y2hcbiAgICAgICAgICogQHByb3BlcnR5IHtpY3MyMy5JQ29tcHJlc3NlZEJhdGNoUHJvb2Z8bnVsbH0gW2NvbXByZXNzZWRdIENvbW1pdG1lbnRQcm9vZiBjb21wcmVzc2VkXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IENvbW1pdG1lbnRQcm9vZi5cbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzXG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIENvbW1pdG1lbnRQcm9vZi5cbiAgICAgICAgICogQGltcGxlbWVudHMgSUNvbW1pdG1lbnRQcm9vZlxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JQ29tbWl0bWVudFByb29mPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBDb21taXRtZW50UHJvb2YocHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21taXRtZW50UHJvb2YgZXhpc3QuXG4gICAgICAgICAqIEBtZW1iZXIge2ljczIzLklFeGlzdGVuY2VQcm9vZnxudWxsfHVuZGVmaW5lZH0gZXhpc3RcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbW1pdG1lbnRQcm9vZlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIENvbW1pdG1lbnRQcm9vZi5wcm90b3R5cGUuZXhpc3QgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21taXRtZW50UHJvb2Ygbm9uZXhpc3QuXG4gICAgICAgICAqIEBtZW1iZXIge2ljczIzLklOb25FeGlzdGVuY2VQcm9vZnxudWxsfHVuZGVmaW5lZH0gbm9uZXhpc3RcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbW1pdG1lbnRQcm9vZlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIENvbW1pdG1lbnRQcm9vZi5wcm90b3R5cGUubm9uZXhpc3QgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21taXRtZW50UHJvb2YgYmF0Y2guXG4gICAgICAgICAqIEBtZW1iZXIge2ljczIzLklCYXRjaFByb29mfG51bGx8dW5kZWZpbmVkfSBiYXRjaFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tbWl0bWVudFByb29mXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQ29tbWl0bWVudFByb29mLnByb3RvdHlwZS5iYXRjaCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbW1pdG1lbnRQcm9vZiBjb21wcmVzc2VkLlxuICAgICAgICAgKiBAbWVtYmVyIHtpY3MyMy5JQ29tcHJlc3NlZEJhdGNoUHJvb2Z8bnVsbHx1bmRlZmluZWR9IGNvbXByZXNzZWRcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbW1pdG1lbnRQcm9vZlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIENvbW1pdG1lbnRQcm9vZi5wcm90b3R5cGUuY29tcHJlc3NlZCA9IG51bGw7XG5cbiAgICAgICAgLy8gT25lT2YgZmllbGQgbmFtZXMgYm91bmQgdG8gdmlydHVhbCBnZXR0ZXJzIGFuZCBzZXR0ZXJzXG4gICAgICAgIHZhciAkb25lT2ZGaWVsZHM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbW1pdG1lbnRQcm9vZiBwcm9vZi5cbiAgICAgICAgICogQG1lbWJlciB7XCJleGlzdFwifFwibm9uZXhpc3RcInxcImJhdGNoXCJ8XCJjb21wcmVzc2VkXCJ8dW5kZWZpbmVkfSBwcm9vZlxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tbWl0bWVudFByb29mXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbW1pdG1lbnRQcm9vZi5wcm90b3R5cGUsIFwicHJvb2ZcIiwge1xuICAgICAgICAgICAgZ2V0OiAkdXRpbC5vbmVPZkdldHRlcigkb25lT2ZGaWVsZHMgPSBbXCJleGlzdFwiLCBcIm5vbmV4aXN0XCIsIFwiYmF0Y2hcIiwgXCJjb21wcmVzc2VkXCJdKSxcbiAgICAgICAgICAgIHNldDogJHV0aWwub25lT2ZTZXR0ZXIoJG9uZU9mRmllbGRzKVxuICAgICAgICB9KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBDb21taXRtZW50UHJvb2YgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21taXRtZW50UHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklDb21taXRtZW50UHJvb2Y9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge2ljczIzLkNvbW1pdG1lbnRQcm9vZn0gQ29tbWl0bWVudFByb29mIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBDb21taXRtZW50UHJvb2YuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tbWl0bWVudFByb29mKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgQ29tbWl0bWVudFByb29mIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIGljczIzLkNvbW1pdG1lbnRQcm9vZi52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tbWl0bWVudFByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JQ29tbWl0bWVudFByb29mfSBtZXNzYWdlIENvbW1pdG1lbnRQcm9vZiBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIENvbW1pdG1lbnRQcm9vZi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZXhpc3QgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZXhpc3RcIikpXG4gICAgICAgICAgICAgICAgJHJvb3QuaWNzMjMuRXhpc3RlbmNlUHJvb2YuZW5jb2RlKG1lc3NhZ2UuZXhpc3QsIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5vbmV4aXN0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm5vbmV4aXN0XCIpKVxuICAgICAgICAgICAgICAgICRyb290LmljczIzLk5vbkV4aXN0ZW5jZVByb29mLmVuY29kZShtZXNzYWdlLm5vbmV4aXN0LCB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5iYXRjaCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJiYXRjaFwiKSlcbiAgICAgICAgICAgICAgICAkcm9vdC5pY3MyMy5CYXRjaFByb29mLmVuY29kZShtZXNzYWdlLmJhdGNoLCB3cml0ZXIudWludDMyKC8qIGlkIDMsIHdpcmVUeXBlIDIgPSovMjYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5jb21wcmVzc2VkICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImNvbXByZXNzZWRcIikpXG4gICAgICAgICAgICAgICAgJHJvb3QuaWNzMjMuQ29tcHJlc3NlZEJhdGNoUHJvb2YuZW5jb2RlKG1lc3NhZ2UuY29tcHJlc3NlZCwgd3JpdGVyLnVpbnQzMigvKiBpZCA0LCB3aXJlVHlwZSAyID0qLzM0KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIENvbW1pdG1lbnRQcm9vZiBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBpY3MyMy5Db21taXRtZW50UHJvb2YudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbW1pdG1lbnRQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSUNvbW1pdG1lbnRQcm9vZn0gbWVzc2FnZSBDb21taXRtZW50UHJvb2YgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBDb21taXRtZW50UHJvb2YuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBDb21taXRtZW50UHJvb2YgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tbWl0bWVudFByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5Db21taXRtZW50UHJvb2Z9IENvbW1pdG1lbnRQcm9vZlxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIENvbW1pdG1lbnRQcm9vZi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5pY3MyMy5Db21taXRtZW50UHJvb2YoKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5leGlzdCA9ICRyb290LmljczIzLkV4aXN0ZW5jZVByb29mLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ub25leGlzdCA9ICRyb290LmljczIzLk5vbkV4aXN0ZW5jZVByb29mLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5iYXRjaCA9ICRyb290LmljczIzLkJhdGNoUHJvb2YuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbXByZXNzZWQgPSAkcm9vdC5pY3MyMy5Db21wcmVzc2VkQmF0Y2hQcm9vZi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgQ29tbWl0bWVudFByb29mIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbW1pdG1lbnRQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuQ29tbWl0bWVudFByb29mfSBDb21taXRtZW50UHJvb2ZcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBDb21taXRtZW50UHJvb2YuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGEgQ29tbWl0bWVudFByb29mIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbW1pdG1lbnRQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgQ29tbWl0bWVudFByb29mLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5leGlzdCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJleGlzdFwiKSkge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucHJvb2YgPSAxO1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuaWNzMjMuRXhpc3RlbmNlUHJvb2YudmVyaWZ5KG1lc3NhZ2UuZXhpc3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJleGlzdC5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5vbmV4aXN0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm5vbmV4aXN0XCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMucHJvb2YgPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInByb29mOiBtdWx0aXBsZSB2YWx1ZXNcIjtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnByb29mID0gMTtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmljczIzLk5vbkV4aXN0ZW5jZVByb29mLnZlcmlmeShtZXNzYWdlLm5vbmV4aXN0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibm9uZXhpc3QuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5iYXRjaCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJiYXRjaFwiKSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLnByb29mID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJwcm9vZjogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5wcm9vZiA9IDE7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5pY3MyMy5CYXRjaFByb29mLnZlcmlmeShtZXNzYWdlLmJhdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYmF0Y2guXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5jb21wcmVzc2VkICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImNvbXByZXNzZWRcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5wcm9vZiA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicHJvb2Y6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucHJvb2YgPSAxO1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuaWNzMjMuQ29tcHJlc3NlZEJhdGNoUHJvb2YudmVyaWZ5KG1lc3NhZ2UuY29tcHJlc3NlZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvbXByZXNzZWQuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIENvbW1pdG1lbnRQcm9vZiBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21taXRtZW50UHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5Db21taXRtZW50UHJvb2Z9IENvbW1pdG1lbnRQcm9vZlxuICAgICAgICAgKi9cbiAgICAgICAgQ29tbWl0bWVudFByb29mLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmljczIzLkNvbW1pdG1lbnRQcm9vZilcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QuaWNzMjMuQ29tbWl0bWVudFByb29mKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmV4aXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5leGlzdCAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmljczIzLkNvbW1pdG1lbnRQcm9vZi5leGlzdDogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXhpc3QgPSAkcm9vdC5pY3MyMy5FeGlzdGVuY2VQcm9vZi5mcm9tT2JqZWN0KG9iamVjdC5leGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0Lm5vbmV4aXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5ub25leGlzdCAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmljczIzLkNvbW1pdG1lbnRQcm9vZi5ub25leGlzdDogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uubm9uZXhpc3QgPSAkcm9vdC5pY3MyMy5Ob25FeGlzdGVuY2VQcm9vZi5mcm9tT2JqZWN0KG9iamVjdC5ub25leGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LmJhdGNoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5iYXRjaCAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmljczIzLkNvbW1pdG1lbnRQcm9vZi5iYXRjaDogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuYmF0Y2ggPSAkcm9vdC5pY3MyMy5CYXRjaFByb29mLmZyb21PYmplY3Qob2JqZWN0LmJhdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QuY29tcHJlc3NlZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuY29tcHJlc3NlZCAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmljczIzLkNvbW1pdG1lbnRQcm9vZi5jb21wcmVzc2VkOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5jb21wcmVzc2VkID0gJHJvb3QuaWNzMjMuQ29tcHJlc3NlZEJhdGNoUHJvb2YuZnJvbU9iamVjdChvYmplY3QuY29tcHJlc3NlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgQ29tbWl0bWVudFByb29mIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21taXRtZW50UHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLkNvbW1pdG1lbnRQcm9vZn0gbWVzc2FnZSBDb21taXRtZW50UHJvb2ZcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBDb21taXRtZW50UHJvb2YudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZXhpc3QgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZXhpc3RcIikpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuZXhpc3QgPSAkcm9vdC5pY3MyMy5FeGlzdGVuY2VQcm9vZi50b09iamVjdChtZXNzYWdlLmV4aXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5wcm9vZiA9IFwiZXhpc3RcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5vbmV4aXN0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm5vbmV4aXN0XCIpKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5vbmV4aXN0ID0gJHJvb3QuaWNzMjMuTm9uRXhpc3RlbmNlUHJvb2YudG9PYmplY3QobWVzc2FnZS5ub25leGlzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QucHJvb2YgPSBcIm5vbmV4aXN0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5iYXRjaCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJiYXRjaFwiKSkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5iYXRjaCA9ICRyb290LmljczIzLkJhdGNoUHJvb2YudG9PYmplY3QobWVzc2FnZS5iYXRjaCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QucHJvb2YgPSBcImJhdGNoXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5jb21wcmVzc2VkICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImNvbXByZXNzZWRcIikpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuY29tcHJlc3NlZCA9ICRyb290LmljczIzLkNvbXByZXNzZWRCYXRjaFByb29mLnRvT2JqZWN0KG1lc3NhZ2UuY29tcHJlc3NlZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QucHJvb2YgPSBcImNvbXByZXNzZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgQ29tbWl0bWVudFByb29mIHRvIEpTT04uXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbW1pdG1lbnRQcm9vZlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgQ29tbWl0bWVudFByb29mLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gQ29tbWl0bWVudFByb29mO1xuICAgIH0pKCk7XG5cbiAgICBpY3MyMy5MZWFmT3AgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBMZWFmT3AuXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyM1xuICAgICAgICAgKiBAaW50ZXJmYWNlIElMZWFmT3BcbiAgICAgICAgICogQHByb3BlcnR5IHtpY3MyMy5IYXNoT3B8bnVsbH0gW2hhc2hdIExlYWZPcCBoYXNoXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7aWNzMjMuSGFzaE9wfG51bGx9IFtwcmVoYXNoS2V5XSBMZWFmT3AgcHJlaGFzaEtleVxuICAgICAgICAgKiBAcHJvcGVydHkge2ljczIzLkhhc2hPcHxudWxsfSBbcHJlaGFzaFZhbHVlXSBMZWFmT3AgcHJlaGFzaFZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7aWNzMjMuTGVuZ3RoT3B8bnVsbH0gW2xlbmd0aF0gTGVhZk9wIGxlbmd0aFxuICAgICAgICAgKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl8bnVsbH0gW3ByZWZpeF0gTGVhZk9wIHByZWZpeFxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBMZWFmT3AuXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyM1xuICAgICAgICAgKiBAY2xhc3NkZXNjIExlYWZPcCByZXByZXNlbnRzIHRoZSByYXcga2V5LXZhbHVlIGRhdGEgd2Ugd2lzaCB0byBwcm92ZSwgYW5kXG4gICAgICAgICAqIG11c3QgYmUgZmxleGlibGUgdG8gcmVwcmVzZW50IHRoZSBpbnRlcm5hbCB0cmFuc2Zvcm1hdGlvbiBmcm9tXG4gICAgICAgICAqIHRoZSBvcmlnaW5hbCBrZXktdmFsdWUgcGFpcnMgaW50byB0aGUgYmFzaXMgaGFzaCwgZm9yIG1hbnkgZXhpc3RpbmdcbiAgICAgICAgICogbWVya2xlIHRyZWVzLlxuICAgICAgICAgKiBcbiAgICAgICAgICoga2V5IGFuZCB2YWx1ZSBhcmUgcGFzc2VkIGluLiBTbyB0aGF0IHRoZSBzaWduYXR1cmUgb2YgdGhpcyBvcGVyYXRpb24gaXM6XG4gICAgICAgICAqIGxlYWZPcChrZXksIHZhbHVlKSAtPiBvdXRwdXRcbiAgICAgICAgICogXG4gICAgICAgICAqIFRvIHByb2Nlc3MgdGhpcywgZmlyc3QgcHJlaGFzaCB0aGUga2V5cyBhbmQgdmFsdWVzIGlmIG5lZWRlZCAoQU5ZIG1lYW5zIG5vIGhhc2ggaW4gdGhpcyBjYXNlKTpcbiAgICAgICAgICogaGtleSA9IHByZWhhc2hLZXkoa2V5KVxuICAgICAgICAgKiBodmFsdWUgPSBwcmVoYXNoVmFsdWUodmFsdWUpXG4gICAgICAgICAqIFxuICAgICAgICAgKiBUaGVuIGNvbWJpbmUgdGhlIGJ5dGVzLCBhbmQgaGFzaCBpdFxuICAgICAgICAgKiBvdXRwdXQgPSBoYXNoKHByZWZpeCB8fCBsZW5ndGgoaGtleSkgfHwgaGtleSB8fCBsZW5ndGgoaHZhbHVlKSB8fCBodmFsdWUpXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElMZWFmT3BcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSUxlYWZPcD19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gTGVhZk9wKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogTGVhZk9wIGhhc2guXG4gICAgICAgICAqIEBtZW1iZXIge2ljczIzLkhhc2hPcH0gaGFzaFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuTGVhZk9wXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTGVhZk9wLnByb3RvdHlwZS5oYXNoID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTGVhZk9wIHByZWhhc2hLZXkuXG4gICAgICAgICAqIEBtZW1iZXIge2ljczIzLkhhc2hPcH0gcHJlaGFzaEtleVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuTGVhZk9wXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTGVhZk9wLnByb3RvdHlwZS5wcmVoYXNoS2V5ID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTGVhZk9wIHByZWhhc2hWYWx1ZS5cbiAgICAgICAgICogQG1lbWJlciB7aWNzMjMuSGFzaE9wfSBwcmVoYXNoVmFsdWVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkxlYWZPcFxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIExlYWZPcC5wcm90b3R5cGUucHJlaGFzaFZhbHVlID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTGVhZk9wIGxlbmd0aC5cbiAgICAgICAgICogQG1lbWJlciB7aWNzMjMuTGVuZ3RoT3B9IGxlbmd0aFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuTGVhZk9wXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTGVhZk9wLnByb3RvdHlwZS5sZW5ndGggPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMZWFmT3AgcHJlZml4LlxuICAgICAgICAgKiBAbWVtYmVyIHtVaW50OEFycmF5fSBwcmVmaXhcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkxlYWZPcFxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIExlYWZPcC5wcm90b3R5cGUucHJlZml4ID0gJHV0aWwubmV3QnVmZmVyKFtdKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBMZWFmT3AgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5MZWFmT3BcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklMZWFmT3A9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge2ljczIzLkxlYWZPcH0gTGVhZk9wIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBMZWFmT3AuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGVhZk9wKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgTGVhZk9wIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIGljczIzLkxlYWZPcC52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuTGVhZk9wXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JTGVhZk9wfSBtZXNzYWdlIExlYWZPcCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIExlYWZPcC5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaGFzaCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJoYXNoXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMCA9Ki84KS5pbnQzMihtZXNzYWdlLmhhc2gpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucHJlaGFzaEtleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwcmVoYXNoS2V5XCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMCA9Ki8xNikuaW50MzIobWVzc2FnZS5wcmVoYXNoS2V5KTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnByZWhhc2hWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwcmVoYXNoVmFsdWVcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAzLCB3aXJlVHlwZSAwID0qLzI0KS5pbnQzMihtZXNzYWdlLnByZWhhc2hWYWx1ZSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5sZW5ndGggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibGVuZ3RoXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNCwgd2lyZVR5cGUgMCA9Ki8zMikuaW50MzIobWVzc2FnZS5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucHJlZml4ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInByZWZpeFwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDUsIHdpcmVUeXBlIDIgPSovNDIpLmJ5dGVzKG1lc3NhZ2UucHJlZml4KTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBMZWFmT3AgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgaWNzMjMuTGVhZk9wLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5MZWFmT3BcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklMZWFmT3B9IG1lc3NhZ2UgTGVhZk9wIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgTGVhZk9wLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgTGVhZk9wIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkxlYWZPcFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuTGVhZk9wfSBMZWFmT3BcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBMZWFmT3AuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuaWNzMjMuTGVhZk9wKCk7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGFzaCA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJlaGFzaEtleSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJlaGFzaFZhbHVlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5sZW5ndGggPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnByZWZpeCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgTGVhZk9wIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkxlYWZPcFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuTGVhZk9wfSBMZWFmT3BcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBMZWFmT3AuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGEgTGVhZk9wIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkxlYWZPcFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgTGVhZk9wLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmhhc2ggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaGFzaFwiKSlcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UuaGFzaCkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImhhc2g6IGVudW0gdmFsdWUgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnByZWhhc2hLZXkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicHJlaGFzaEtleVwiKSlcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UucHJlaGFzaEtleSkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInByZWhhc2hLZXk6IGVudW0gdmFsdWUgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnByZWhhc2hWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwcmVoYXNoVmFsdWVcIikpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnByZWhhc2hWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInByZWhhc2hWYWx1ZTogZW51bSB2YWx1ZSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubGVuZ3RoICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImxlbmd0aFwiKSlcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGVuZ3RoOiBlbnVtIHZhbHVlIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnByZWZpeCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwcmVmaXhcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5wcmVmaXggJiYgdHlwZW9mIG1lc3NhZ2UucHJlZml4Lmxlbmd0aCA9PT0gXCJudW1iZXJcIiB8fCAkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnByZWZpeCkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJwcmVmaXg6IGJ1ZmZlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBMZWFmT3AgbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuTGVhZk9wXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuTGVhZk9wfSBMZWFmT3BcbiAgICAgICAgICovXG4gICAgICAgIExlYWZPcC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5pY3MyMy5MZWFmT3ApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmljczIzLkxlYWZPcCgpO1xuICAgICAgICAgICAgc3dpdGNoIChvYmplY3QuaGFzaCkge1xuICAgICAgICAgICAgY2FzZSBcIk5PX0hBU0hcIjpcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmhhc2ggPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNIQTI1NlwiOlxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGFzaCA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiU0hBNTEyXCI6XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5oYXNoID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJLRUNDQUtcIjpcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmhhc2ggPSAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlJJUEVNRDE2MFwiOlxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGFzaCA9IDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQklUQ09JTlwiOlxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGFzaCA9IDU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiU0hBNTEyXzI1NlwiOlxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGFzaCA9IDY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKG9iamVjdC5wcmVoYXNoS2V5KSB7XG4gICAgICAgICAgICBjYXNlIFwiTk9fSEFTSFwiOlxuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJlaGFzaEtleSA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiU0hBMjU2XCI6XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5wcmVoYXNoS2V5ID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTSEE1MTJcIjpcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnByZWhhc2hLZXkgPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIktFQ0NBS1wiOlxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJlaGFzaEtleSA9IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiUklQRU1EMTYwXCI6XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5wcmVoYXNoS2V5ID0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJCSVRDT0lOXCI6XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5wcmVoYXNoS2V5ID0gNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTSEE1MTJfMjU2XCI6XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5wcmVoYXNoS2V5ID0gNjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAob2JqZWN0LnByZWhhc2hWYWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBcIk5PX0hBU0hcIjpcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnByZWhhc2hWYWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiU0hBMjU2XCI6XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5wcmVoYXNoVmFsdWUgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNIQTUxMlwiOlxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJlaGFzaFZhbHVlID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJLRUNDQUtcIjpcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnByZWhhc2hWYWx1ZSA9IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiUklQRU1EMTYwXCI6XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5wcmVoYXNoVmFsdWUgPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkJJVENPSU5cIjpcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnByZWhhc2hWYWx1ZSA9IDU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiU0hBNTEyXzI1NlwiOlxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJlaGFzaFZhbHVlID0gNjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAob2JqZWN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSBcIk5PX1BSRUZJWFwiOlxuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJWQVJfUFJPVE9cIjpcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmxlbmd0aCA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiVkFSX1JMUFwiOlxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UubGVuZ3RoID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJGSVhFRDMyX0JJR1wiOlxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UubGVuZ3RoID0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJGSVhFRDMyX0xJVFRMRVwiOlxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UubGVuZ3RoID0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJGSVhFRDY0X0JJR1wiOlxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UubGVuZ3RoID0gNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJGSVhFRDY0X0xJVFRMRVwiOlxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UubGVuZ3RoID0gNjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJSRVFVSVJFXzMyX0JZVEVTXCI6XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5sZW5ndGggPSA3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlJFUVVJUkVfNjRfQllURVNcIjpcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmxlbmd0aCA9IDg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LnByZWZpeCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnByZWZpeCA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgJHV0aWwuYmFzZTY0LmRlY29kZShvYmplY3QucHJlZml4LCBtZXNzYWdlLnByZWZpeCA9ICR1dGlsLm5ld0J1ZmZlcigkdXRpbC5iYXNlNjQubGVuZ3RoKG9iamVjdC5wcmVmaXgpKSwgMCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2JqZWN0LnByZWZpeC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJlZml4ID0gb2JqZWN0LnByZWZpeDtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBMZWFmT3AgbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkxlYWZPcFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuTGVhZk9wfSBtZXNzYWdlIExlYWZPcFxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIExlYWZPcC50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIG9iamVjdC5oYXNoID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gXCJOT19IQVNIXCIgOiAwO1xuICAgICAgICAgICAgICAgIG9iamVjdC5wcmVoYXNoS2V5ID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gXCJOT19IQVNIXCIgOiAwO1xuICAgICAgICAgICAgICAgIG9iamVjdC5wcmVoYXNoVmFsdWUgPSBvcHRpb25zLmVudW1zID09PSBTdHJpbmcgPyBcIk5PX0hBU0hcIiA6IDA7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lmxlbmd0aCA9IG9wdGlvbnMuZW51bXMgPT09IFN0cmluZyA/IFwiTk9fUFJFRklYXCIgOiAwO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzID09PSBTdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5wcmVmaXggPSBcIlwiO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3QucHJlZml4ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzICE9PSBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5wcmVmaXggPSAkdXRpbC5uZXdCdWZmZXIob2JqZWN0LnByZWZpeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaGFzaCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJoYXNoXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5oYXNoID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gJHJvb3QuaWNzMjMuSGFzaE9wW21lc3NhZ2UuaGFzaF0gOiBtZXNzYWdlLmhhc2g7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5wcmVoYXNoS2V5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInByZWhhc2hLZXlcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnByZWhhc2hLZXkgPSBvcHRpb25zLmVudW1zID09PSBTdHJpbmcgPyAkcm9vdC5pY3MyMy5IYXNoT3BbbWVzc2FnZS5wcmVoYXNoS2V5XSA6IG1lc3NhZ2UucHJlaGFzaEtleTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnByZWhhc2hWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwcmVoYXNoVmFsdWVcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnByZWhhc2hWYWx1ZSA9IG9wdGlvbnMuZW51bXMgPT09IFN0cmluZyA/ICRyb290LmljczIzLkhhc2hPcFttZXNzYWdlLnByZWhhc2hWYWx1ZV0gOiBtZXNzYWdlLnByZWhhc2hWYWx1ZTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmxlbmd0aCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJsZW5ndGhcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0Lmxlbmd0aCA9IG9wdGlvbnMuZW51bXMgPT09IFN0cmluZyA/ICRyb290LmljczIzLkxlbmd0aE9wW21lc3NhZ2UubGVuZ3RoXSA6IG1lc3NhZ2UubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucHJlZml4ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInByZWZpeFwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QucHJlZml4ID0gb3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nID8gJHV0aWwuYmFzZTY0LmVuY29kZShtZXNzYWdlLnByZWZpeCwgMCwgbWVzc2FnZS5wcmVmaXgubGVuZ3RoKSA6IG9wdGlvbnMuYnl0ZXMgPT09IEFycmF5ID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobWVzc2FnZS5wcmVmaXgpIDogbWVzc2FnZS5wcmVmaXg7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIExlYWZPcCB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5MZWFmT3BcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIExlYWZPcC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIExlYWZPcDtcbiAgICB9KSgpO1xuXG4gICAgaWNzMjMuSW5uZXJPcCA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhbiBJbm5lck9wLlxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjNcbiAgICAgICAgICogQGludGVyZmFjZSBJSW5uZXJPcFxuICAgICAgICAgKiBAcHJvcGVydHkge2ljczIzLkhhc2hPcHxudWxsfSBbaGFzaF0gSW5uZXJPcCBoYXNoXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7VWludDhBcnJheXxudWxsfSBbcHJlZml4XSBJbm5lck9wIHByZWZpeFxuICAgICAgICAgKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl8bnVsbH0gW3N1ZmZpeF0gSW5uZXJPcCBzdWZmaXhcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgSW5uZXJPcC5cbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzXG4gICAgICAgICAqIEBjbGFzc2Rlc2MgSW5uZXJPcCByZXByZXNlbnRzIGEgbWVya2xlLXByb29mIHN0ZXAgdGhhdCBpcyBub3QgYSBsZWFmLlxuICAgICAgICAgKiBJdCByZXByZXNlbnRzIGNvbmNhdGVuYXRpbmcgdHdvIGNoaWxkcmVuIGFuZCBoYXNoaW5nIHRoZW0gdG8gcHJvdmlkZSB0aGUgbmV4dCByZXN1bHQuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBUaGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBzdGVwIGlzIHBhc3NlZCBpbiwgc28gdGhlIHNpZ25hdHVyZSBvZiB0aGlzIG9wIGlzOlxuICAgICAgICAgKiBpbm5lck9wKGNoaWxkKSAtPiBvdXRwdXRcbiAgICAgICAgICogXG4gICAgICAgICAqIFRoZSByZXN1bHQgb2YgYXBwbHlpbmcgSW5uZXJPcCBzaG91bGQgYmU6XG4gICAgICAgICAqIG91dHB1dCA9IG9wLmhhc2gob3AucHJlZml4IHx8IGNoaWxkIHx8IG9wLnN1ZmZpeClcbiAgICAgICAgICogXG4gICAgICAgICAqIHdoZXJlIHRoZSB8fCBvcGVyYXRvciBpcyBjb25jYXRlbmF0aW9uIG9mIGJpbmFyeSBkYXRhLFxuICAgICAgICAgKiBhbmQgY2hpbGQgaXMgdGhlIHJlc3VsdCBvZiBoYXNoaW5nIGFsbCB0aGUgdHJlZSBiZWxvdyB0aGlzIHN0ZXAuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBBbnkgc3BlY2lhbCBkYXRhLCBsaWtlIHByZXBlbmRpbmcgY2hpbGQgd2l0aCB0aGUgbGVuZ3RoLCBvciBwcmVwZW5kaW5nIHRoZSBlbnRpcmUgb3BlcmF0aW9uIHdpdGhcbiAgICAgICAgICogc29tZSB2YWx1ZSB0byBkaWZmZXJlbnRpYXRlIGZyb20gbGVhZiBub2Rlcywgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHByZWZpeCBhbmQgc3VmZml4LlxuICAgICAgICAgKiBJZiBlaXRoZXIgb2YgcHJlZml4IG9yIHN1ZmZpeCBpcyBlbXB0eSwgd2UganVzdCB0cmVhdCBpdCBhcyBhbiBlbXB0eSBzdHJpbmdcbiAgICAgICAgICogQGltcGxlbWVudHMgSUlubmVyT3BcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSUlubmVyT3A9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIElubmVyT3AocHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbm5lck9wIGhhc2guXG4gICAgICAgICAqIEBtZW1iZXIge2ljczIzLkhhc2hPcH0gaGFzaFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuSW5uZXJPcFxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIElubmVyT3AucHJvdG90eXBlLmhhc2ggPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbm5lck9wIHByZWZpeC5cbiAgICAgICAgICogQG1lbWJlciB7VWludDhBcnJheX0gcHJlZml4XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Jbm5lck9wXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgSW5uZXJPcC5wcm90b3R5cGUucHJlZml4ID0gJHV0aWwubmV3QnVmZmVyKFtdKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5uZXJPcCBzdWZmaXguXG4gICAgICAgICAqIEBtZW1iZXIge1VpbnQ4QXJyYXl9IHN1ZmZpeFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuSW5uZXJPcFxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIElubmVyT3AucHJvdG90eXBlLnN1ZmZpeCA9ICR1dGlsLm5ld0J1ZmZlcihbXSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgSW5uZXJPcCBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLklubmVyT3BcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklJbm5lck9wPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5Jbm5lck9wfSBJbm5lck9wIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBJbm5lck9wLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IElubmVyT3AocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBJbm5lck9wIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIGljczIzLklubmVyT3AudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLklubmVyT3BcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklJbm5lck9wfSBtZXNzYWdlIElubmVyT3AgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBJbm5lck9wLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5oYXNoICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImhhc2hcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAwID0qLzgpLmludDMyKG1lc3NhZ2UuaGFzaCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5wcmVmaXggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicHJlZml4XCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8xOCkuYnl0ZXMobWVzc2FnZS5wcmVmaXgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc3VmZml4ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInN1ZmZpeFwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDMsIHdpcmVUeXBlIDIgPSovMjYpLmJ5dGVzKG1lc3NhZ2Uuc3VmZml4KTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBJbm5lck9wIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIGljczIzLklubmVyT3AudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLklubmVyT3BcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklJbm5lck9wfSBtZXNzYWdlIElubmVyT3AgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBJbm5lck9wLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGFuIElubmVyT3AgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuSW5uZXJPcFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuSW5uZXJPcH0gSW5uZXJPcFxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIElubmVyT3AuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuaWNzMjMuSW5uZXJPcCgpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmhhc2ggPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnByZWZpeCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3VmZml4ID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYW4gSW5uZXJPcCBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Jbm5lck9wXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5Jbm5lck9wfSBJbm5lck9wXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgSW5uZXJPcC5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYW4gSW5uZXJPcCBtZXNzYWdlLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Jbm5lck9wXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAqL1xuICAgICAgICBJbm5lck9wLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmhhc2ggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaGFzaFwiKSlcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UuaGFzaCkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImhhc2g6IGVudW0gdmFsdWUgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnByZWZpeCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwcmVmaXhcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5wcmVmaXggJiYgdHlwZW9mIG1lc3NhZ2UucHJlZml4Lmxlbmd0aCA9PT0gXCJudW1iZXJcIiB8fCAkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnByZWZpeCkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJwcmVmaXg6IGJ1ZmZlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc3VmZml4ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInN1ZmZpeFwiKSlcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnN1ZmZpeCAmJiB0eXBlb2YgbWVzc2FnZS5zdWZmaXgubGVuZ3RoID09PSBcIm51bWJlclwiIHx8ICR1dGlsLmlzU3RyaW5nKG1lc3NhZ2Uuc3VmZml4KSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInN1ZmZpeDogYnVmZmVyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhbiBJbm5lck9wIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLklubmVyT3BcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5Jbm5lck9wfSBJbm5lck9wXG4gICAgICAgICAqL1xuICAgICAgICBJbm5lck9wLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmljczIzLklubmVyT3ApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmljczIzLklubmVyT3AoKTtcbiAgICAgICAgICAgIHN3aXRjaCAob2JqZWN0Lmhhc2gpIHtcbiAgICAgICAgICAgIGNhc2UgXCJOT19IQVNIXCI6XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5oYXNoID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTSEEyNTZcIjpcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmhhc2ggPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNIQTUxMlwiOlxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGFzaCA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiS0VDQ0FLXCI6XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5oYXNoID0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJSSVBFTUQxNjBcIjpcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmhhc2ggPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkJJVENPSU5cIjpcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmhhc2ggPSA1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNIQTUxMl8yNTZcIjpcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmhhc2ggPSA2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5wcmVmaXggIT0gbnVsbClcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5wcmVmaXggPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICR1dGlsLmJhc2U2NC5kZWNvZGUob2JqZWN0LnByZWZpeCwgbWVzc2FnZS5wcmVmaXggPSAkdXRpbC5uZXdCdWZmZXIoJHV0aWwuYmFzZTY0Lmxlbmd0aChvYmplY3QucHJlZml4KSksIDApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9iamVjdC5wcmVmaXgubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnByZWZpeCA9IG9iamVjdC5wcmVmaXg7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnN1ZmZpeCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnN1ZmZpeCA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgJHV0aWwuYmFzZTY0LmRlY29kZShvYmplY3Quc3VmZml4LCBtZXNzYWdlLnN1ZmZpeCA9ICR1dGlsLm5ld0J1ZmZlcigkdXRpbC5iYXNlNjQubGVuZ3RoKG9iamVjdC5zdWZmaXgpKSwgMCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2JqZWN0LnN1ZmZpeC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3VmZml4ID0gb2JqZWN0LnN1ZmZpeDtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYW4gSW5uZXJPcCBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuSW5uZXJPcFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSW5uZXJPcH0gbWVzc2FnZSBJbm5lck9wXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgSW5uZXJPcC50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIG9iamVjdC5oYXNoID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gXCJOT19IQVNIXCIgOiAwO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzID09PSBTdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5wcmVmaXggPSBcIlwiO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3QucHJlZml4ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzICE9PSBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5wcmVmaXggPSAkdXRpbC5uZXdCdWZmZXIob2JqZWN0LnByZWZpeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzID09PSBTdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5zdWZmaXggPSBcIlwiO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3Quc3VmZml4ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzICE9PSBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5zdWZmaXggPSAkdXRpbC5uZXdCdWZmZXIob2JqZWN0LnN1ZmZpeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaGFzaCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJoYXNoXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5oYXNoID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gJHJvb3QuaWNzMjMuSGFzaE9wW21lc3NhZ2UuaGFzaF0gOiBtZXNzYWdlLmhhc2g7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5wcmVmaXggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicHJlZml4XCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5wcmVmaXggPSBvcHRpb25zLmJ5dGVzID09PSBTdHJpbmcgPyAkdXRpbC5iYXNlNjQuZW5jb2RlKG1lc3NhZ2UucHJlZml4LCAwLCBtZXNzYWdlLnByZWZpeC5sZW5ndGgpIDogb3B0aW9ucy5ieXRlcyA9PT0gQXJyYXkgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZXNzYWdlLnByZWZpeCkgOiBtZXNzYWdlLnByZWZpeDtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnN1ZmZpeCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzdWZmaXhcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnN1ZmZpeCA9IG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZyA/ICR1dGlsLmJhc2U2NC5lbmNvZGUobWVzc2FnZS5zdWZmaXgsIDAsIG1lc3NhZ2Uuc3VmZml4Lmxlbmd0aCkgOiBvcHRpb25zLmJ5dGVzID09PSBBcnJheSA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG1lc3NhZ2Uuc3VmZml4KSA6IG1lc3NhZ2Uuc3VmZml4O1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBJbm5lck9wIHRvIEpTT04uXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLklubmVyT3BcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIElubmVyT3AucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBJbm5lck9wO1xuICAgIH0pKCk7XG5cbiAgICBpY3MyMy5Qcm9vZlNwZWMgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBQcm9vZlNwZWMuXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyM1xuICAgICAgICAgKiBAaW50ZXJmYWNlIElQcm9vZlNwZWNcbiAgICAgICAgICogQHByb3BlcnR5IHtpY3MyMy5JTGVhZk9wfG51bGx9IFtsZWFmU3BlY10gUHJvb2ZTcGVjIGxlYWZTcGVjXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7aWNzMjMuSUlubmVyU3BlY3xudWxsfSBbaW5uZXJTcGVjXSBQcm9vZlNwZWMgaW5uZXJTcGVjXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFttYXhEZXB0aF0gUHJvb2ZTcGVjIG1heERlcHRoXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFttaW5EZXB0aF0gUHJvb2ZTcGVjIG1pbkRlcHRoXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFByb29mU3BlYy5cbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzXG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUHJvb2ZTcGVjIGRlZmluZXMgd2hhdCB0aGUgZXhwZWN0ZWQgcGFyYW1ldGVycyBhcmUgZm9yIGEgZ2l2ZW4gcHJvb2YgdHlwZS5cbiAgICAgICAgICogVGhpcyBjYW4gYmUgc3RvcmVkIGluIHRoZSBjbGllbnQgYW5kIHVzZWQgdG8gdmFsaWRhdGUgYW55IGluY29taW5nIHByb29mcy5cbiAgICAgICAgICogXG4gICAgICAgICAqIHZlcmlmeShQcm9vZlNwZWMsIFByb29mKSAtPiBQcm9vZiB8IEVycm9yXG4gICAgICAgICAqIFxuICAgICAgICAgKiBBcyBkZW1vbnN0cmF0ZWQgaW4gdGVzdHMsIGlmIHdlIGRvbid0IGZpeCB0aGUgYWxnb3JpdGhtIHVzZWQgdG8gY2FsY3VsYXRlIHRoZVxuICAgICAgICAgKiBMZWFmSGFzaCBmb3IgYSBnaXZlbiB0cmVlLCB0aGVyZSBhcmUgbWFueSBwb3NzaWJsZSBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW5cbiAgICAgICAgICogZ2VuZXJhdGUgYSBnaXZlbiBoYXNoIChieSBpbnRlcnByZXR0aW5nIHRoZSBwcmVpbWFnZSBkaWZmZXJlbnRseSkuXG4gICAgICAgICAqIFdlIG5lZWQgdGhpcyBmb3IgcHJvcGVyIHNlY3VyaXR5LCByZXF1aXJlcyBjbGllbnQga25vd3MgYSBwcmlvcmkgd2hhdFxuICAgICAgICAgKiB0cmVlIGZvcm1hdCBzZXJ2ZXIgdXNlcy4gQnV0IG5vdCBpbiBjb2RlLCByYXRoZXIgYSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgICAgICogQGltcGxlbWVudHMgSVByb29mU3BlY1xuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JUHJvb2ZTcGVjPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBQcm9vZlNwZWMocHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9vZlNwZWMgbGVhZlNwZWMuXG4gICAgICAgICAqIEBtZW1iZXIge2ljczIzLklMZWFmT3B8bnVsbHx1bmRlZmluZWR9IGxlYWZTcGVjXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Qcm9vZlNwZWNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBQcm9vZlNwZWMucHJvdG90eXBlLmxlYWZTcGVjID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvb2ZTcGVjIGlubmVyU3BlYy5cbiAgICAgICAgICogQG1lbWJlciB7aWNzMjMuSUlubmVyU3BlY3xudWxsfHVuZGVmaW5lZH0gaW5uZXJTcGVjXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Qcm9vZlNwZWNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBQcm9vZlNwZWMucHJvdG90eXBlLmlubmVyU3BlYyA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb29mU3BlYyBtYXhEZXB0aC5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBtYXhEZXB0aFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuUHJvb2ZTcGVjXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgUHJvb2ZTcGVjLnByb3RvdHlwZS5tYXhEZXB0aCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb29mU3BlYyBtaW5EZXB0aC5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBtaW5EZXB0aFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuUHJvb2ZTcGVjXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgUHJvb2ZTcGVjLnByb3RvdHlwZS5taW5EZXB0aCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgUHJvb2ZTcGVjIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuUHJvb2ZTcGVjXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JUHJvb2ZTcGVjPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5Qcm9vZlNwZWN9IFByb29mU3BlYyBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgUHJvb2ZTcGVjLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb29mU3BlYyhwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFByb29mU3BlYyBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBpY3MyMy5Qcm9vZlNwZWMudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLlByb29mU3BlY1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSVByb29mU3BlY30gbWVzc2FnZSBQcm9vZlNwZWMgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBQcm9vZlNwZWMuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmxlYWZTcGVjICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImxlYWZTcGVjXCIpKVxuICAgICAgICAgICAgICAgICRyb290LmljczIzLkxlYWZPcC5lbmNvZGUobWVzc2FnZS5sZWFmU3BlYywgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLzEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW5uZXJTcGVjICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImlubmVyU3BlY1wiKSlcbiAgICAgICAgICAgICAgICAkcm9vdC5pY3MyMy5Jbm5lclNwZWMuZW5jb2RlKG1lc3NhZ2UuaW5uZXJTcGVjLCB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXhEZXB0aCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJtYXhEZXB0aFwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDMsIHdpcmVUeXBlIDAgPSovMjQpLmludDMyKG1lc3NhZ2UubWF4RGVwdGgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWluRGVwdGggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibWluRGVwdGhcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA0LCB3aXJlVHlwZSAwID0qLzMyKS5pbnQzMihtZXNzYWdlLm1pbkRlcHRoKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBQcm9vZlNwZWMgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgaWNzMjMuUHJvb2ZTcGVjLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Qcm9vZlNwZWNcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklQcm9vZlNwZWN9IG1lc3NhZ2UgUHJvb2ZTcGVjIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgUHJvb2ZTcGVjLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgUHJvb2ZTcGVjIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLlByb29mU3BlY1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuUHJvb2ZTcGVjfSBQcm9vZlNwZWNcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBQcm9vZlNwZWMuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuaWNzMjMuUHJvb2ZTcGVjKCk7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubGVhZlNwZWMgPSAkcm9vdC5pY3MyMy5MZWFmT3AuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlubmVyU3BlYyA9ICRyb290LmljczIzLklubmVyU3BlYy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWF4RGVwdGggPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1pbkRlcHRoID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBQcm9vZlNwZWMgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuUHJvb2ZTcGVjXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5Qcm9vZlNwZWN9IFByb29mU3BlY1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIFByb29mU3BlYy5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYSBQcm9vZlNwZWMgbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuUHJvb2ZTcGVjXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAqL1xuICAgICAgICBQcm9vZlNwZWMudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubGVhZlNwZWMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibGVhZlNwZWNcIikpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5pY3MyMy5MZWFmT3AudmVyaWZ5KG1lc3NhZ2UubGVhZlNwZWMpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGVhZlNwZWMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmlubmVyU3BlYyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpbm5lclNwZWNcIikpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5pY3MyMy5Jbm5lclNwZWMudmVyaWZ5KG1lc3NhZ2UuaW5uZXJTcGVjKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImlubmVyU3BlYy5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF4RGVwdGggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibWF4RGVwdGhcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5tYXhEZXB0aCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm1heERlcHRoOiBpbnRlZ2VyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5taW5EZXB0aCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJtaW5EZXB0aFwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLm1pbkRlcHRoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibWluRGVwdGg6IGludGVnZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgUHJvb2ZTcGVjIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLlByb29mU3BlY1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge2ljczIzLlByb29mU3BlY30gUHJvb2ZTcGVjXG4gICAgICAgICAqL1xuICAgICAgICBQcm9vZlNwZWMuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuaWNzMjMuUHJvb2ZTcGVjKVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5pY3MyMy5Qcm9vZlNwZWMoKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QubGVhZlNwZWMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmxlYWZTcGVjICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuaWNzMjMuUHJvb2ZTcGVjLmxlYWZTcGVjOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5sZWFmU3BlYyA9ICRyb290LmljczIzLkxlYWZPcC5mcm9tT2JqZWN0KG9iamVjdC5sZWFmU3BlYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LmlubmVyU3BlYyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuaW5uZXJTcGVjICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuaWNzMjMuUHJvb2ZTcGVjLmlubmVyU3BlYzogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5uZXJTcGVjID0gJHJvb3QuaWNzMjMuSW5uZXJTcGVjLmZyb21PYmplY3Qob2JqZWN0LmlubmVyU3BlYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0Lm1heERlcHRoICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5tYXhEZXB0aCA9IG9iamVjdC5tYXhEZXB0aCB8IDA7XG4gICAgICAgICAgICBpZiAob2JqZWN0Lm1pbkRlcHRoICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5taW5EZXB0aCA9IG9iamVjdC5taW5EZXB0aCB8IDA7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgUHJvb2ZTcGVjIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Qcm9vZlNwZWNcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLlByb29mU3BlY30gbWVzc2FnZSBQcm9vZlNwZWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBQcm9vZlNwZWMudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QubGVhZlNwZWMgPSBudWxsO1xuICAgICAgICAgICAgICAgIG9iamVjdC5pbm5lclNwZWMgPSBudWxsO1xuICAgICAgICAgICAgICAgIG9iamVjdC5tYXhEZXB0aCA9IDA7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm1pbkRlcHRoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmxlYWZTcGVjICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImxlYWZTcGVjXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5sZWFmU3BlYyA9ICRyb290LmljczIzLkxlYWZPcC50b09iamVjdChtZXNzYWdlLmxlYWZTcGVjLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmlubmVyU3BlYyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpbm5lclNwZWNcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmlubmVyU3BlYyA9ICRyb290LmljczIzLklubmVyU3BlYy50b09iamVjdChtZXNzYWdlLmlubmVyU3BlYywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXhEZXB0aCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJtYXhEZXB0aFwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QubWF4RGVwdGggPSBtZXNzYWdlLm1heERlcHRoO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWluRGVwdGggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibWluRGVwdGhcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0Lm1pbkRlcHRoID0gbWVzc2FnZS5taW5EZXB0aDtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgUHJvb2ZTcGVjIHRvIEpTT04uXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLlByb29mU3BlY1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgUHJvb2ZTcGVjLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gUHJvb2ZTcGVjO1xuICAgIH0pKCk7XG5cbiAgICBpY3MyMy5Jbm5lclNwZWMgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYW4gSW5uZXJTcGVjLlxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjNcbiAgICAgICAgICogQGludGVyZmFjZSBJSW5uZXJTcGVjXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj58bnVsbH0gW2NoaWxkT3JkZXJdIElubmVyU3BlYyBjaGlsZE9yZGVyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFtjaGlsZFNpemVdIElubmVyU3BlYyBjaGlsZFNpemVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW21pblByZWZpeExlbmd0aF0gSW5uZXJTcGVjIG1pblByZWZpeExlbmd0aFxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbbWF4UHJlZml4TGVuZ3RoXSBJbm5lclNwZWMgbWF4UHJlZml4TGVuZ3RoXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7VWludDhBcnJheXxudWxsfSBbZW1wdHlDaGlsZF0gSW5uZXJTcGVjIGVtcHR5Q2hpbGRcbiAgICAgICAgICogQHByb3BlcnR5IHtpY3MyMy5IYXNoT3B8bnVsbH0gW2hhc2hdIElubmVyU3BlYyBoYXNoXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IElubmVyU3BlYy5cbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzXG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhbiBJbm5lclNwZWMuXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElJbm5lclNwZWNcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSUlubmVyU3BlYz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gSW5uZXJTcGVjKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRPcmRlciA9IFtdO1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbm5lclNwZWMgY2hpbGRPcmRlci5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcj59IGNoaWxkT3JkZXJcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLklubmVyU3BlY1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIElubmVyU3BlYy5wcm90b3R5cGUuY2hpbGRPcmRlciA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElubmVyU3BlYyBjaGlsZFNpemUuXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gY2hpbGRTaXplXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Jbm5lclNwZWNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBJbm5lclNwZWMucHJvdG90eXBlLmNoaWxkU2l6ZSA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElubmVyU3BlYyBtaW5QcmVmaXhMZW5ndGguXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gbWluUHJlZml4TGVuZ3RoXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Jbm5lclNwZWNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBJbm5lclNwZWMucHJvdG90eXBlLm1pblByZWZpeExlbmd0aCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElubmVyU3BlYyBtYXhQcmVmaXhMZW5ndGguXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gbWF4UHJlZml4TGVuZ3RoXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Jbm5lclNwZWNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBJbm5lclNwZWMucHJvdG90eXBlLm1heFByZWZpeExlbmd0aCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElubmVyU3BlYyBlbXB0eUNoaWxkLlxuICAgICAgICAgKiBAbWVtYmVyIHtVaW50OEFycmF5fSBlbXB0eUNoaWxkXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Jbm5lclNwZWNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBJbm5lclNwZWMucHJvdG90eXBlLmVtcHR5Q2hpbGQgPSAkdXRpbC5uZXdCdWZmZXIoW10pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbm5lclNwZWMgaGFzaC5cbiAgICAgICAgICogQG1lbWJlciB7aWNzMjMuSGFzaE9wfSBoYXNoXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Jbm5lclNwZWNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBJbm5lclNwZWMucHJvdG90eXBlLmhhc2ggPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IElubmVyU3BlYyBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLklubmVyU3BlY1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSUlubmVyU3BlYz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuSW5uZXJTcGVjfSBJbm5lclNwZWMgaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIElubmVyU3BlYy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbm5lclNwZWMocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBJbm5lclNwZWMgbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgaWNzMjMuSW5uZXJTcGVjLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Jbm5lclNwZWNcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklJbm5lclNwZWN9IG1lc3NhZ2UgSW5uZXJTcGVjIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgSW5uZXJTcGVjLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5jaGlsZE9yZGVyICE9IG51bGwgJiYgbWVzc2FnZS5jaGlsZE9yZGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuZm9yaygpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5jaGlsZE9yZGVyLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIuaW50MzIobWVzc2FnZS5jaGlsZE9yZGVyW2ldKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIubGRlbGltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5jaGlsZFNpemUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiY2hpbGRTaXplXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMCA9Ki8xNikuaW50MzIobWVzc2FnZS5jaGlsZFNpemUpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWluUHJlZml4TGVuZ3RoICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm1pblByZWZpeExlbmd0aFwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDMsIHdpcmVUeXBlIDAgPSovMjQpLmludDMyKG1lc3NhZ2UubWluUHJlZml4TGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1heFByZWZpeExlbmd0aCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJtYXhQcmVmaXhMZW5ndGhcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA0LCB3aXJlVHlwZSAwID0qLzMyKS5pbnQzMihtZXNzYWdlLm1heFByZWZpeExlbmd0aCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5lbXB0eUNoaWxkICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImVtcHR5Q2hpbGRcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA1LCB3aXJlVHlwZSAyID0qLzQyKS5ieXRlcyhtZXNzYWdlLmVtcHR5Q2hpbGQpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaGFzaCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJoYXNoXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNiwgd2lyZVR5cGUgMCA9Ki80OCkuaW50MzIobWVzc2FnZS5oYXNoKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBJbm5lclNwZWMgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgaWNzMjMuSW5uZXJTcGVjLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Jbm5lclNwZWNcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklJbm5lclNwZWN9IG1lc3NhZ2UgSW5uZXJTcGVjIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgSW5uZXJTcGVjLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGFuIElubmVyU3BlYyBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Jbm5lclNwZWNcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge2ljczIzLklubmVyU3BlY30gSW5uZXJTcGVjXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgSW5uZXJTcGVjLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmljczIzLklubmVyU3BlYygpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmNoaWxkT3JkZXIgJiYgbWVzc2FnZS5jaGlsZE9yZGVyLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNoaWxkT3JkZXIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2hpbGRPcmRlci5wdXNoKHJlYWRlci5pbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNoaWxkT3JkZXIucHVzaChyZWFkZXIuaW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jaGlsZFNpemUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1pblByZWZpeExlbmd0aCA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWF4UHJlZml4TGVuZ3RoID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lbXB0eUNoaWxkID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5oYXNoID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYW4gSW5uZXJTcGVjIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLklubmVyU3BlY1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuSW5uZXJTcGVjfSBJbm5lclNwZWNcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBJbm5lclNwZWMuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGFuIElubmVyU3BlYyBtZXNzYWdlLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Jbm5lclNwZWNcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIElubmVyU3BlYy52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5jaGlsZE9yZGVyICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImNoaWxkT3JkZXJcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5jaGlsZE9yZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY2hpbGRPcmRlcjogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuY2hpbGRPcmRlci5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5jaGlsZE9yZGVyW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNoaWxkT3JkZXI6IGludGVnZXJbXSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuY2hpbGRTaXplICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImNoaWxkU2l6ZVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmNoaWxkU2l6ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNoaWxkU2l6ZTogaW50ZWdlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWluUHJlZml4TGVuZ3RoICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm1pblByZWZpeExlbmd0aFwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLm1pblByZWZpeExlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm1pblByZWZpeExlbmd0aDogaW50ZWdlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF4UHJlZml4TGVuZ3RoICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm1heFByZWZpeExlbmd0aFwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLm1heFByZWZpeExlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm1heFByZWZpeExlbmd0aDogaW50ZWdlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZW1wdHlDaGlsZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJlbXB0eUNoaWxkXCIpKVxuICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuZW1wdHlDaGlsZCAmJiB0eXBlb2YgbWVzc2FnZS5lbXB0eUNoaWxkLmxlbmd0aCA9PT0gXCJudW1iZXJcIiB8fCAkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmVtcHR5Q2hpbGQpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZW1wdHlDaGlsZDogYnVmZmVyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5oYXNoICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImhhc2hcIikpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLmhhc2gpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJoYXNoOiBlbnVtIHZhbHVlIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhbiBJbm5lclNwZWMgbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuSW5uZXJTcGVjXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuSW5uZXJTcGVjfSBJbm5lclNwZWNcbiAgICAgICAgICovXG4gICAgICAgIElubmVyU3BlYy5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5pY3MyMy5Jbm5lclNwZWMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmljczIzLklubmVyU3BlYygpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5jaGlsZE9yZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5jaGlsZE9yZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmljczIzLklubmVyU3BlYy5jaGlsZE9yZGVyOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmNoaWxkT3JkZXIgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5jaGlsZE9yZGVyLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNoaWxkT3JkZXJbaV0gPSBvYmplY3QuY2hpbGRPcmRlcltpXSB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LmNoaWxkU2l6ZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2hpbGRTaXplID0gb2JqZWN0LmNoaWxkU2l6ZSB8IDA7XG4gICAgICAgICAgICBpZiAob2JqZWN0Lm1pblByZWZpeExlbmd0aCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UubWluUHJlZml4TGVuZ3RoID0gb2JqZWN0Lm1pblByZWZpeExlbmd0aCB8IDA7XG4gICAgICAgICAgICBpZiAob2JqZWN0Lm1heFByZWZpeExlbmd0aCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UubWF4UHJlZml4TGVuZ3RoID0gb2JqZWN0Lm1heFByZWZpeExlbmd0aCB8IDA7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmVtcHR5Q2hpbGQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5lbXB0eUNoaWxkID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAkdXRpbC5iYXNlNjQuZGVjb2RlKG9iamVjdC5lbXB0eUNoaWxkLCBtZXNzYWdlLmVtcHR5Q2hpbGQgPSAkdXRpbC5uZXdCdWZmZXIoJHV0aWwuYmFzZTY0Lmxlbmd0aChvYmplY3QuZW1wdHlDaGlsZCkpLCAwKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvYmplY3QuZW1wdHlDaGlsZC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZW1wdHlDaGlsZCA9IG9iamVjdC5lbXB0eUNoaWxkO1xuICAgICAgICAgICAgc3dpdGNoIChvYmplY3QuaGFzaCkge1xuICAgICAgICAgICAgY2FzZSBcIk5PX0hBU0hcIjpcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmhhc2ggPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNIQTI1NlwiOlxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGFzaCA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiU0hBNTEyXCI6XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5oYXNoID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJLRUNDQUtcIjpcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmhhc2ggPSAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlJJUEVNRDE2MFwiOlxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGFzaCA9IDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQklUQ09JTlwiOlxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGFzaCA9IDU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiU0hBNTEyXzI1NlwiOlxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGFzaCA9IDY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGFuIElubmVyU3BlYyBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuSW5uZXJTcGVjXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5Jbm5lclNwZWN9IG1lc3NhZ2UgSW5uZXJTcGVjXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgSW5uZXJTcGVjLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgICAgIG9iamVjdC5jaGlsZE9yZGVyID0gW107XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIG9iamVjdC5jaGlsZFNpemUgPSAwO1xuICAgICAgICAgICAgICAgIG9iamVjdC5taW5QcmVmaXhMZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIG9iamVjdC5tYXhQcmVmaXhMZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzID09PSBTdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5lbXB0eUNoaWxkID0gXCJcIjtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmVtcHR5Q2hpbGQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZXMgIT09IEFycmF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmVtcHR5Q2hpbGQgPSAkdXRpbC5uZXdCdWZmZXIob2JqZWN0LmVtcHR5Q2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmplY3QuaGFzaCA9IG9wdGlvbnMuZW51bXMgPT09IFN0cmluZyA/IFwiTk9fSEFTSFwiIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmNoaWxkT3JkZXIgJiYgbWVzc2FnZS5jaGlsZE9yZGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5jaGlsZE9yZGVyID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmNoaWxkT3JkZXIubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5jaGlsZE9yZGVyW2pdID0gbWVzc2FnZS5jaGlsZE9yZGVyW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuY2hpbGRTaXplICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImNoaWxkU2l6ZVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuY2hpbGRTaXplID0gbWVzc2FnZS5jaGlsZFNpemU7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5taW5QcmVmaXhMZW5ndGggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibWluUHJlZml4TGVuZ3RoXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5taW5QcmVmaXhMZW5ndGggPSBtZXNzYWdlLm1pblByZWZpeExlbmd0aDtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1heFByZWZpeExlbmd0aCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJtYXhQcmVmaXhMZW5ndGhcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0Lm1heFByZWZpeExlbmd0aCA9IG1lc3NhZ2UubWF4UHJlZml4TGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZW1wdHlDaGlsZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJlbXB0eUNoaWxkXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5lbXB0eUNoaWxkID0gb3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nID8gJHV0aWwuYmFzZTY0LmVuY29kZShtZXNzYWdlLmVtcHR5Q2hpbGQsIDAsIG1lc3NhZ2UuZW1wdHlDaGlsZC5sZW5ndGgpIDogb3B0aW9ucy5ieXRlcyA9PT0gQXJyYXkgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZXNzYWdlLmVtcHR5Q2hpbGQpIDogbWVzc2FnZS5lbXB0eUNoaWxkO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaGFzaCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJoYXNoXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5oYXNoID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gJHJvb3QuaWNzMjMuSGFzaE9wW21lc3NhZ2UuaGFzaF0gOiBtZXNzYWdlLmhhc2g7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIElubmVyU3BlYyB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Jbm5lclNwZWNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIElubmVyU3BlYy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIElubmVyU3BlYztcbiAgICB9KSgpO1xuXG4gICAgaWNzMjMuQmF0Y2hQcm9vZiA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIEJhdGNoUHJvb2YuXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyM1xuICAgICAgICAgKiBAaW50ZXJmYWNlIElCYXRjaFByb29mXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPGljczIzLklCYXRjaEVudHJ5PnxudWxsfSBbZW50cmllc10gQmF0Y2hQcm9vZiBlbnRyaWVzXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEJhdGNoUHJvb2YuXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyM1xuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBCYXRjaFByb29mLlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJQmF0Y2hQcm9vZlxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JQmF0Y2hQcm9vZj19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQmF0Y2hQcm9vZihwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLmVudHJpZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQmF0Y2hQcm9vZiBlbnRyaWVzLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48aWNzMjMuSUJhdGNoRW50cnk+fSBlbnRyaWVzXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5CYXRjaFByb29mXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQmF0Y2hQcm9vZi5wcm90b3R5cGUuZW50cmllcyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgQmF0Y2hQcm9vZiBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkJhdGNoUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklCYXRjaFByb29mPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5CYXRjaFByb29mfSBCYXRjaFByb29mIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBCYXRjaFByb29mLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJhdGNoUHJvb2YocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBCYXRjaFByb29mIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIGljczIzLkJhdGNoUHJvb2YudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkJhdGNoUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklCYXRjaFByb29mfSBtZXNzYWdlIEJhdGNoUHJvb2YgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBCYXRjaFByb29mLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5lbnRyaWVzICE9IG51bGwgJiYgbWVzc2FnZS5lbnRyaWVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZW50cmllcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3QuaWNzMjMuQmF0Y2hFbnRyeS5lbmNvZGUobWVzc2FnZS5lbnRyaWVzW2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgQmF0Y2hQcm9vZiBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBpY3MyMy5CYXRjaFByb29mLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5CYXRjaFByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JQmF0Y2hQcm9vZn0gbWVzc2FnZSBCYXRjaFByb29mIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgQmF0Y2hQcm9vZi5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIEJhdGNoUHJvb2YgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQmF0Y2hQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuQmF0Y2hQcm9vZn0gQmF0Y2hQcm9vZlxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIEJhdGNoUHJvb2YuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuaWNzMjMuQmF0Y2hQcm9vZigpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmVudHJpZXMgJiYgbWVzc2FnZS5lbnRyaWVzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVudHJpZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lbnRyaWVzLnB1c2goJHJvb3QuaWNzMjMuQmF0Y2hFbnRyeS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIEJhdGNoUHJvb2YgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQmF0Y2hQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuQmF0Y2hQcm9vZn0gQmF0Y2hQcm9vZlxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIEJhdGNoUHJvb2YuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGEgQmF0Y2hQcm9vZiBtZXNzYWdlLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5CYXRjaFByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAqL1xuICAgICAgICBCYXRjaFByb29mLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmVudHJpZXMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZW50cmllc1wiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmVudHJpZXMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJlbnRyaWVzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5lbnRyaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmljczIzLkJhdGNoRW50cnkudmVyaWZ5KG1lc3NhZ2UuZW50cmllc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImVudHJpZXMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIEJhdGNoUHJvb2YgbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQmF0Y2hQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge2ljczIzLkJhdGNoUHJvb2Z9IEJhdGNoUHJvb2ZcbiAgICAgICAgICovXG4gICAgICAgIEJhdGNoUHJvb2YuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuaWNzMjMuQmF0Y2hQcm9vZilcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QuaWNzMjMuQmF0Y2hQcm9vZigpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5lbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5lbnRyaWVzKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmljczIzLkJhdGNoUHJvb2YuZW50cmllczogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5lbnRyaWVzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuZW50cmllcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5lbnRyaWVzW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmljczIzLkJhdGNoUHJvb2YuZW50cmllczogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVudHJpZXNbaV0gPSAkcm9vdC5pY3MyMy5CYXRjaEVudHJ5LmZyb21PYmplY3Qob2JqZWN0LmVudHJpZXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBCYXRjaFByb29mIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5CYXRjaFByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5CYXRjaFByb29mfSBtZXNzYWdlIEJhdGNoUHJvb2ZcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBCYXRjaFByb29mLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgICAgIG9iamVjdC5lbnRyaWVzID0gW107XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5lbnRyaWVzICYmIG1lc3NhZ2UuZW50cmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuZW50cmllcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5lbnRyaWVzLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuZW50cmllc1tqXSA9ICRyb290LmljczIzLkJhdGNoRW50cnkudG9PYmplY3QobWVzc2FnZS5lbnRyaWVzW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgQmF0Y2hQcm9vZiB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5CYXRjaFByb29mXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBCYXRjaFByb29mLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gQmF0Y2hQcm9vZjtcbiAgICB9KSgpO1xuXG4gICAgaWNzMjMuQmF0Y2hFbnRyeSA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIEJhdGNoRW50cnkuXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyM1xuICAgICAgICAgKiBAaW50ZXJmYWNlIElCYXRjaEVudHJ5XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7aWNzMjMuSUV4aXN0ZW5jZVByb29mfG51bGx9IFtleGlzdF0gQmF0Y2hFbnRyeSBleGlzdFxuICAgICAgICAgKiBAcHJvcGVydHkge2ljczIzLklOb25FeGlzdGVuY2VQcm9vZnxudWxsfSBbbm9uZXhpc3RdIEJhdGNoRW50cnkgbm9uZXhpc3RcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgQmF0Y2hFbnRyeS5cbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzXG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIEJhdGNoRW50cnkuXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElCYXRjaEVudHJ5XG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklCYXRjaEVudHJ5PX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBCYXRjaEVudHJ5KHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQmF0Y2hFbnRyeSBleGlzdC5cbiAgICAgICAgICogQG1lbWJlciB7aWNzMjMuSUV4aXN0ZW5jZVByb29mfG51bGx8dW5kZWZpbmVkfSBleGlzdFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQmF0Y2hFbnRyeVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEJhdGNoRW50cnkucHJvdG90eXBlLmV4aXN0ID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQmF0Y2hFbnRyeSBub25leGlzdC5cbiAgICAgICAgICogQG1lbWJlciB7aWNzMjMuSU5vbkV4aXN0ZW5jZVByb29mfG51bGx8dW5kZWZpbmVkfSBub25leGlzdFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQmF0Y2hFbnRyeVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEJhdGNoRW50cnkucHJvdG90eXBlLm5vbmV4aXN0ID0gbnVsbDtcblxuICAgICAgICAvLyBPbmVPZiBmaWVsZCBuYW1lcyBib3VuZCB0byB2aXJ0dWFsIGdldHRlcnMgYW5kIHNldHRlcnNcbiAgICAgICAgdmFyICRvbmVPZkZpZWxkcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQmF0Y2hFbnRyeSBwcm9vZi5cbiAgICAgICAgICogQG1lbWJlciB7XCJleGlzdFwifFwibm9uZXhpc3RcInx1bmRlZmluZWR9IHByb29mXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5CYXRjaEVudHJ5XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhdGNoRW50cnkucHJvdG90eXBlLCBcInByb29mXCIsIHtcbiAgICAgICAgICAgIGdldDogJHV0aWwub25lT2ZHZXR0ZXIoJG9uZU9mRmllbGRzID0gW1wiZXhpc3RcIiwgXCJub25leGlzdFwiXSksXG4gICAgICAgICAgICBzZXQ6ICR1dGlsLm9uZU9mU2V0dGVyKCRvbmVPZkZpZWxkcylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgQmF0Y2hFbnRyeSBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkJhdGNoRW50cnlcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklCYXRjaEVudHJ5PX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5CYXRjaEVudHJ5fSBCYXRjaEVudHJ5IGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBCYXRjaEVudHJ5LmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJhdGNoRW50cnkocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBCYXRjaEVudHJ5IG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIGljczIzLkJhdGNoRW50cnkudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkJhdGNoRW50cnlcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklCYXRjaEVudHJ5fSBtZXNzYWdlIEJhdGNoRW50cnkgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBCYXRjaEVudHJ5LmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5leGlzdCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJleGlzdFwiKSlcbiAgICAgICAgICAgICAgICAkcm9vdC5pY3MyMy5FeGlzdGVuY2VQcm9vZi5lbmNvZGUobWVzc2FnZS5leGlzdCwgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLzEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uubm9uZXhpc3QgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibm9uZXhpc3RcIikpXG4gICAgICAgICAgICAgICAgJHJvb3QuaWNzMjMuTm9uRXhpc3RlbmNlUHJvb2YuZW5jb2RlKG1lc3NhZ2Uubm9uZXhpc3QsIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8xOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBCYXRjaEVudHJ5IG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIGljczIzLkJhdGNoRW50cnkudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkJhdGNoRW50cnlcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklCYXRjaEVudHJ5fSBtZXNzYWdlIEJhdGNoRW50cnkgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBCYXRjaEVudHJ5LmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgQmF0Y2hFbnRyeSBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5CYXRjaEVudHJ5XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5CYXRjaEVudHJ5fSBCYXRjaEVudHJ5XG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgQmF0Y2hFbnRyeS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5pY3MyMy5CYXRjaEVudHJ5KCk7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXhpc3QgPSAkcm9vdC5pY3MyMy5FeGlzdGVuY2VQcm9vZi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uubm9uZXhpc3QgPSAkcm9vdC5pY3MyMy5Ob25FeGlzdGVuY2VQcm9vZi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgQmF0Y2hFbnRyeSBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5CYXRjaEVudHJ5XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5CYXRjaEVudHJ5fSBCYXRjaEVudHJ5XG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgQmF0Y2hFbnRyeS5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYSBCYXRjaEVudHJ5IG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkJhdGNoRW50cnlcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIEJhdGNoRW50cnkudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmV4aXN0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImV4aXN0XCIpKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5wcm9vZiA9IDE7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5pY3MyMy5FeGlzdGVuY2VQcm9vZi52ZXJpZnkobWVzc2FnZS5leGlzdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImV4aXN0LlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uubm9uZXhpc3QgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibm9uZXhpc3RcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5wcm9vZiA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicHJvb2Y6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucHJvb2YgPSAxO1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuaWNzMjMuTm9uRXhpc3RlbmNlUHJvb2YudmVyaWZ5KG1lc3NhZ2Uubm9uZXhpc3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJub25leGlzdC5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgQmF0Y2hFbnRyeSBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5CYXRjaEVudHJ5XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuQmF0Y2hFbnRyeX0gQmF0Y2hFbnRyeVxuICAgICAgICAgKi9cbiAgICAgICAgQmF0Y2hFbnRyeS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5pY3MyMy5CYXRjaEVudHJ5KVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5pY3MyMy5CYXRjaEVudHJ5KCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmV4aXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5leGlzdCAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmljczIzLkJhdGNoRW50cnkuZXhpc3Q6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmV4aXN0ID0gJHJvb3QuaWNzMjMuRXhpc3RlbmNlUHJvb2YuZnJvbU9iamVjdChvYmplY3QuZXhpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5ub25leGlzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Qubm9uZXhpc3QgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5pY3MyMy5CYXRjaEVudHJ5Lm5vbmV4aXN0OiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5ub25leGlzdCA9ICRyb290LmljczIzLk5vbkV4aXN0ZW5jZVByb29mLmZyb21PYmplY3Qob2JqZWN0Lm5vbmV4aXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBCYXRjaEVudHJ5IG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5CYXRjaEVudHJ5XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5CYXRjaEVudHJ5fSBtZXNzYWdlIEJhdGNoRW50cnlcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBCYXRjaEVudHJ5LnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmV4aXN0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImV4aXN0XCIpKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmV4aXN0ID0gJHJvb3QuaWNzMjMuRXhpc3RlbmNlUHJvb2YudG9PYmplY3QobWVzc2FnZS5leGlzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QucHJvb2YgPSBcImV4aXN0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ub25leGlzdCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJub25leGlzdFwiKSkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5ub25leGlzdCA9ICRyb290LmljczIzLk5vbkV4aXN0ZW5jZVByb29mLnRvT2JqZWN0KG1lc3NhZ2Uubm9uZXhpc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnByb29mID0gXCJub25leGlzdFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBCYXRjaEVudHJ5IHRvIEpTT04uXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkJhdGNoRW50cnlcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIEJhdGNoRW50cnkucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBCYXRjaEVudHJ5O1xuICAgIH0pKCk7XG5cbiAgICBpY3MyMy5Db21wcmVzc2VkQmF0Y2hQcm9vZiA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIENvbXByZXNzZWRCYXRjaFByb29mLlxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjNcbiAgICAgICAgICogQGludGVyZmFjZSBJQ29tcHJlc3NlZEJhdGNoUHJvb2ZcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48aWNzMjMuSUNvbXByZXNzZWRCYXRjaEVudHJ5PnxudWxsfSBbZW50cmllc10gQ29tcHJlc3NlZEJhdGNoUHJvb2YgZW50cmllc1xuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxpY3MyMy5JSW5uZXJPcD58bnVsbH0gW2xvb2t1cElubmVyc10gQ29tcHJlc3NlZEJhdGNoUHJvb2YgbG9va3VwSW5uZXJzXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IENvbXByZXNzZWRCYXRjaFByb29mLlxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjNcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgQ29tcHJlc3NlZEJhdGNoUHJvb2YuXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElDb21wcmVzc2VkQmF0Y2hQcm9vZlxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JQ29tcHJlc3NlZEJhdGNoUHJvb2Y9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIENvbXByZXNzZWRCYXRjaFByb29mKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZW50cmllcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5sb29rdXBJbm5lcnMgPSBbXTtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcHJlc3NlZEJhdGNoUHJvb2YgZW50cmllcy5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPGljczIzLklDb21wcmVzc2VkQmF0Y2hFbnRyeT59IGVudHJpZXNcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWRCYXRjaFByb29mXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZEJhdGNoUHJvb2YucHJvdG90eXBlLmVudHJpZXMgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wcmVzc2VkQmF0Y2hQcm9vZiBsb29rdXBJbm5lcnMuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxpY3MyMy5JSW5uZXJPcD59IGxvb2t1cElubmVyc1xuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tcHJlc3NlZEJhdGNoUHJvb2ZcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkQmF0Y2hQcm9vZi5wcm90b3R5cGUubG9va3VwSW5uZXJzID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBDb21wcmVzc2VkQmF0Y2hQcm9vZiBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWRCYXRjaFByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JQ29tcHJlc3NlZEJhdGNoUHJvb2Y9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge2ljczIzLkNvbXByZXNzZWRCYXRjaFByb29mfSBDb21wcmVzc2VkQmF0Y2hQcm9vZiBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZEJhdGNoUHJvb2YuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcHJlc3NlZEJhdGNoUHJvb2YocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBDb21wcmVzc2VkQmF0Y2hQcm9vZiBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBpY3MyMy5Db21wcmVzc2VkQmF0Y2hQcm9vZi52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tcHJlc3NlZEJhdGNoUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklDb21wcmVzc2VkQmF0Y2hQcm9vZn0gbWVzc2FnZSBDb21wcmVzc2VkQmF0Y2hQcm9vZiBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWRCYXRjaFByb29mLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5lbnRyaWVzICE9IG51bGwgJiYgbWVzc2FnZS5lbnRyaWVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZW50cmllcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3QuaWNzMjMuQ29tcHJlc3NlZEJhdGNoRW50cnkuZW5jb2RlKG1lc3NhZ2UuZW50cmllc1tpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLzEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubG9va3VwSW5uZXJzICE9IG51bGwgJiYgbWVzc2FnZS5sb29rdXBJbm5lcnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5sb29rdXBJbm5lcnMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290LmljczIzLklubmVyT3AuZW5jb2RlKG1lc3NhZ2UubG9va3VwSW5uZXJzW2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgQ29tcHJlc3NlZEJhdGNoUHJvb2YgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgaWNzMjMuQ29tcHJlc3NlZEJhdGNoUHJvb2YudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWRCYXRjaFByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JQ29tcHJlc3NlZEJhdGNoUHJvb2Z9IG1lc3NhZ2UgQ29tcHJlc3NlZEJhdGNoUHJvb2YgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkQmF0Y2hQcm9vZi5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIENvbXByZXNzZWRCYXRjaFByb29mIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWRCYXRjaFByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5Db21wcmVzc2VkQmF0Y2hQcm9vZn0gQ29tcHJlc3NlZEJhdGNoUHJvb2ZcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkQmF0Y2hQcm9vZi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5pY3MyMy5Db21wcmVzc2VkQmF0Y2hQcm9vZigpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmVudHJpZXMgJiYgbWVzc2FnZS5lbnRyaWVzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVudHJpZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lbnRyaWVzLnB1c2goJHJvb3QuaWNzMjMuQ29tcHJlc3NlZEJhdGNoRW50cnkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5sb29rdXBJbm5lcnMgJiYgbWVzc2FnZS5sb29rdXBJbm5lcnMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubG9va3VwSW5uZXJzID0gW107XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubG9va3VwSW5uZXJzLnB1c2goJHJvb3QuaWNzMjMuSW5uZXJPcC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIENvbXByZXNzZWRCYXRjaFByb29mIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWRCYXRjaFByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5Db21wcmVzc2VkQmF0Y2hQcm9vZn0gQ29tcHJlc3NlZEJhdGNoUHJvb2ZcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkQmF0Y2hQcm9vZi5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYSBDb21wcmVzc2VkQmF0Y2hQcm9vZiBtZXNzYWdlLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkQmF0Y2hQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZEJhdGNoUHJvb2YudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZW50cmllcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJlbnRyaWVzXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuZW50cmllcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImVudHJpZXM6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmVudHJpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuaWNzMjMuQ29tcHJlc3NlZEJhdGNoRW50cnkudmVyaWZ5KG1lc3NhZ2UuZW50cmllc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImVudHJpZXMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5sb29rdXBJbm5lcnMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibG9va3VwSW5uZXJzXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UubG9va3VwSW5uZXJzKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibG9va3VwSW5uZXJzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5sb29rdXBJbm5lcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuaWNzMjMuSW5uZXJPcC52ZXJpZnkobWVzc2FnZS5sb29rdXBJbm5lcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJsb29rdXBJbm5lcnMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIENvbXByZXNzZWRCYXRjaFByb29mIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWRCYXRjaFByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuQ29tcHJlc3NlZEJhdGNoUHJvb2Z9IENvbXByZXNzZWRCYXRjaFByb29mXG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkQmF0Y2hQcm9vZi5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5pY3MyMy5Db21wcmVzc2VkQmF0Y2hQcm9vZilcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QuaWNzMjMuQ29tcHJlc3NlZEJhdGNoUHJvb2YoKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuZW50cmllcykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuZW50cmllcykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5pY3MyMy5Db21wcmVzc2VkQmF0Y2hQcm9vZi5lbnRyaWVzOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmVudHJpZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5lbnRyaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmVudHJpZXNbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuaWNzMjMuQ29tcHJlc3NlZEJhdGNoUHJvb2YuZW50cmllczogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVudHJpZXNbaV0gPSAkcm9vdC5pY3MyMy5Db21wcmVzc2VkQmF0Y2hFbnRyeS5mcm9tT2JqZWN0KG9iamVjdC5lbnRyaWVzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0Lmxvb2t1cElubmVycykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QubG9va3VwSW5uZXJzKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmljczIzLkNvbXByZXNzZWRCYXRjaFByb29mLmxvb2t1cElubmVyczogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5sb29rdXBJbm5lcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5sb29rdXBJbm5lcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QubG9va3VwSW5uZXJzW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmljczIzLkNvbXByZXNzZWRCYXRjaFByb29mLmxvb2t1cElubmVyczogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmxvb2t1cElubmVyc1tpXSA9ICRyb290LmljczIzLklubmVyT3AuZnJvbU9iamVjdChvYmplY3QubG9va3VwSW5uZXJzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgQ29tcHJlc3NlZEJhdGNoUHJvb2YgbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWRCYXRjaFByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5Db21wcmVzc2VkQmF0Y2hQcm9vZn0gbWVzc2FnZSBDb21wcmVzc2VkQmF0Y2hQcm9vZlxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWRCYXRjaFByb29mLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmVudHJpZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3QubG9va3VwSW5uZXJzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5lbnRyaWVzICYmIG1lc3NhZ2UuZW50cmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuZW50cmllcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5lbnRyaWVzLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuZW50cmllc1tqXSA9ICRyb290LmljczIzLkNvbXByZXNzZWRCYXRjaEVudHJ5LnRvT2JqZWN0KG1lc3NhZ2UuZW50cmllc1tqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5sb29rdXBJbm5lcnMgJiYgbWVzc2FnZS5sb29rdXBJbm5lcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lmxvb2t1cElubmVycyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5sb29rdXBJbm5lcnMubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5sb29rdXBJbm5lcnNbal0gPSAkcm9vdC5pY3MyMy5Jbm5lck9wLnRvT2JqZWN0KG1lc3NhZ2UubG9va3VwSW5uZXJzW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgQ29tcHJlc3NlZEJhdGNoUHJvb2YgdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tcHJlc3NlZEJhdGNoUHJvb2ZcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWRCYXRjaFByb29mLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gQ29tcHJlc3NlZEJhdGNoUHJvb2Y7XG4gICAgfSkoKTtcblxuICAgIGljczIzLkNvbXByZXNzZWRCYXRjaEVudHJ5ID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgQ29tcHJlc3NlZEJhdGNoRW50cnkuXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyM1xuICAgICAgICAgKiBAaW50ZXJmYWNlIElDb21wcmVzc2VkQmF0Y2hFbnRyeVxuICAgICAgICAgKiBAcHJvcGVydHkge2ljczIzLklDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2Z8bnVsbH0gW2V4aXN0XSBDb21wcmVzc2VkQmF0Y2hFbnRyeSBleGlzdFxuICAgICAgICAgKiBAcHJvcGVydHkge2ljczIzLklDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2Z8bnVsbH0gW25vbmV4aXN0XSBDb21wcmVzc2VkQmF0Y2hFbnRyeSBub25leGlzdFxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBDb21wcmVzc2VkQmF0Y2hFbnRyeS5cbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzXG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIENvbXByZXNzZWRCYXRjaEVudHJ5LlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJQ29tcHJlc3NlZEJhdGNoRW50cnlcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSUNvbXByZXNzZWRCYXRjaEVudHJ5PX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBDb21wcmVzc2VkQmF0Y2hFbnRyeShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXByZXNzZWRCYXRjaEVudHJ5IGV4aXN0LlxuICAgICAgICAgKiBAbWVtYmVyIHtpY3MyMy5JQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mfG51bGx8dW5kZWZpbmVkfSBleGlzdFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tcHJlc3NlZEJhdGNoRW50cnlcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkQmF0Y2hFbnRyeS5wcm90b3R5cGUuZXhpc3QgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wcmVzc2VkQmF0Y2hFbnRyeSBub25leGlzdC5cbiAgICAgICAgICogQG1lbWJlciB7aWNzMjMuSUNvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZnxudWxsfHVuZGVmaW5lZH0gbm9uZXhpc3RcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWRCYXRjaEVudHJ5XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZEJhdGNoRW50cnkucHJvdG90eXBlLm5vbmV4aXN0ID0gbnVsbDtcblxuICAgICAgICAvLyBPbmVPZiBmaWVsZCBuYW1lcyBib3VuZCB0byB2aXJ0dWFsIGdldHRlcnMgYW5kIHNldHRlcnNcbiAgICAgICAgdmFyICRvbmVPZkZpZWxkcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcHJlc3NlZEJhdGNoRW50cnkgcHJvb2YuXG4gICAgICAgICAqIEBtZW1iZXIge1wiZXhpc3RcInxcIm5vbmV4aXN0XCJ8dW5kZWZpbmVkfSBwcm9vZlxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tcHJlc3NlZEJhdGNoRW50cnlcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcHJlc3NlZEJhdGNoRW50cnkucHJvdG90eXBlLCBcInByb29mXCIsIHtcbiAgICAgICAgICAgIGdldDogJHV0aWwub25lT2ZHZXR0ZXIoJG9uZU9mRmllbGRzID0gW1wiZXhpc3RcIiwgXCJub25leGlzdFwiXSksXG4gICAgICAgICAgICBzZXQ6ICR1dGlsLm9uZU9mU2V0dGVyKCRvbmVPZkZpZWxkcylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgQ29tcHJlc3NlZEJhdGNoRW50cnkgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkQmF0Y2hFbnRyeVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSUNvbXByZXNzZWRCYXRjaEVudHJ5PX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5Db21wcmVzc2VkQmF0Y2hFbnRyeX0gQ29tcHJlc3NlZEJhdGNoRW50cnkgaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWRCYXRjaEVudHJ5LmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXByZXNzZWRCYXRjaEVudHJ5KHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgQ29tcHJlc3NlZEJhdGNoRW50cnkgbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgaWNzMjMuQ29tcHJlc3NlZEJhdGNoRW50cnkudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWRCYXRjaEVudHJ5XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JQ29tcHJlc3NlZEJhdGNoRW50cnl9IG1lc3NhZ2UgQ29tcHJlc3NlZEJhdGNoRW50cnkgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkQmF0Y2hFbnRyeS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZXhpc3QgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZXhpc3RcIikpXG4gICAgICAgICAgICAgICAgJHJvb3QuaWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mLmVuY29kZShtZXNzYWdlLmV4aXN0LCB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ub25leGlzdCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJub25leGlzdFwiKSlcbiAgICAgICAgICAgICAgICAkcm9vdC5pY3MyMy5Db21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2YuZW5jb2RlKG1lc3NhZ2Uubm9uZXhpc3QsIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8xOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBDb21wcmVzc2VkQmF0Y2hFbnRyeSBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBpY3MyMy5Db21wcmVzc2VkQmF0Y2hFbnRyeS52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tcHJlc3NlZEJhdGNoRW50cnlcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklDb21wcmVzc2VkQmF0Y2hFbnRyeX0gbWVzc2FnZSBDb21wcmVzc2VkQmF0Y2hFbnRyeSBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWRCYXRjaEVudHJ5LmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgQ29tcHJlc3NlZEJhdGNoRW50cnkgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tcHJlc3NlZEJhdGNoRW50cnlcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge2ljczIzLkNvbXByZXNzZWRCYXRjaEVudHJ5fSBDb21wcmVzc2VkQmF0Y2hFbnRyeVxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWRCYXRjaEVudHJ5LmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmljczIzLkNvbXByZXNzZWRCYXRjaEVudHJ5KCk7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXhpc3QgPSAkcm9vdC5pY3MyMy5Db21wcmVzc2VkRXhpc3RlbmNlUHJvb2YuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5vbmV4aXN0ID0gJHJvb3QuaWNzMjMuQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBDb21wcmVzc2VkQmF0Y2hFbnRyeSBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkQmF0Y2hFbnRyeVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuQ29tcHJlc3NlZEJhdGNoRW50cnl9IENvbXByZXNzZWRCYXRjaEVudHJ5XG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZEJhdGNoRW50cnkuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGEgQ29tcHJlc3NlZEJhdGNoRW50cnkgbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tcHJlc3NlZEJhdGNoRW50cnlcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWRCYXRjaEVudHJ5LnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5leGlzdCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJleGlzdFwiKSkge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucHJvb2YgPSAxO1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuaWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mLnZlcmlmeShtZXNzYWdlLmV4aXN0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZXhpc3QuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ub25leGlzdCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJub25leGlzdFwiKSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLnByb29mID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJwcm9vZjogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5wcm9vZiA9IDE7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5pY3MyMy5Db21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2YudmVyaWZ5KG1lc3NhZ2Uubm9uZXhpc3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJub25leGlzdC5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgQ29tcHJlc3NlZEJhdGNoRW50cnkgbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tcHJlc3NlZEJhdGNoRW50cnlcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5Db21wcmVzc2VkQmF0Y2hFbnRyeX0gQ29tcHJlc3NlZEJhdGNoRW50cnlcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWRCYXRjaEVudHJ5LmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmljczIzLkNvbXByZXNzZWRCYXRjaEVudHJ5KVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5pY3MyMy5Db21wcmVzc2VkQmF0Y2hFbnRyeSgpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5leGlzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuZXhpc3QgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5pY3MyMy5Db21wcmVzc2VkQmF0Y2hFbnRyeS5leGlzdDogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXhpc3QgPSAkcm9vdC5pY3MyMy5Db21wcmVzc2VkRXhpc3RlbmNlUHJvb2YuZnJvbU9iamVjdChvYmplY3QuZXhpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5ub25leGlzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Qubm9uZXhpc3QgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5pY3MyMy5Db21wcmVzc2VkQmF0Y2hFbnRyeS5ub25leGlzdDogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uubm9uZXhpc3QgPSAkcm9vdC5pY3MyMy5Db21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2YuZnJvbU9iamVjdChvYmplY3Qubm9uZXhpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIENvbXByZXNzZWRCYXRjaEVudHJ5IG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkQmF0Y2hFbnRyeVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuQ29tcHJlc3NlZEJhdGNoRW50cnl9IG1lc3NhZ2UgQ29tcHJlc3NlZEJhdGNoRW50cnlcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkQmF0Y2hFbnRyeS50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5leGlzdCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJleGlzdFwiKSkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5leGlzdCA9ICRyb290LmljczIzLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZi50b09iamVjdChtZXNzYWdlLmV4aXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5wcm9vZiA9IFwiZXhpc3RcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5vbmV4aXN0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm5vbmV4aXN0XCIpKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5vbmV4aXN0ID0gJHJvb3QuaWNzMjMuQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mLnRvT2JqZWN0KG1lc3NhZ2Uubm9uZXhpc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnByb29mID0gXCJub25leGlzdFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBDb21wcmVzc2VkQmF0Y2hFbnRyeSB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkQmF0Y2hFbnRyeVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZEJhdGNoRW50cnkucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBDb21wcmVzc2VkQmF0Y2hFbnRyeTtcbiAgICB9KSgpO1xuXG4gICAgaWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mLlxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjNcbiAgICAgICAgICogQGludGVyZmFjZSBJQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7VWludDhBcnJheXxudWxsfSBba2V5XSBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2Yga2V5XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7VWludDhBcnJheXxudWxsfSBbdmFsdWVdIENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZiB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge2ljczIzLklMZWFmT3B8bnVsbH0gW2xlYWZdIENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZiBsZWFmXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj58bnVsbH0gW3BhdGhdIENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZiBwYXRoXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZi5cbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzXG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZi5cbiAgICAgICAgICogQGltcGxlbWVudHMgSUNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2YocHJvcGVydGllcykge1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gW107XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZiBrZXkuXG4gICAgICAgICAqIEBtZW1iZXIge1VpbnQ4QXJyYXl9IGtleVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mLnByb3RvdHlwZS5rZXkgPSAkdXRpbC5uZXdCdWZmZXIoW10pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2YgdmFsdWUuXG4gICAgICAgICAqIEBtZW1iZXIge1VpbnQ4QXJyYXl9IHZhbHVlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2YucHJvdG90eXBlLnZhbHVlID0gJHV0aWwubmV3QnVmZmVyKFtdKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mIGxlYWYuXG4gICAgICAgICAqIEBtZW1iZXIge2ljczIzLklMZWFmT3B8bnVsbHx1bmRlZmluZWR9IGxlYWZcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZi5wcm90b3R5cGUubGVhZiA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZiBwYXRoLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyPn0gcGF0aFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mLnByb3RvdHlwZS5wYXRoID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2YgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2Y9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge2ljczIzLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZn0gQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2YuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIGljczIzLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZi52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mfSBtZXNzYWdlIENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZiBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uua2V5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLmJ5dGVzKG1lc3NhZ2Uua2V5KTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8xOCkuYnl0ZXMobWVzc2FnZS52YWx1ZSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5sZWFmICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImxlYWZcIikpXG4gICAgICAgICAgICAgICAgJHJvb3QuaWNzMjMuTGVhZk9wLmVuY29kZShtZXNzYWdlLmxlYWYsIHdyaXRlci51aW50MzIoLyogaWQgMywgd2lyZVR5cGUgMiA9Ki8yNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnBhdGggIT0gbnVsbCAmJiBtZXNzYWdlLnBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA0LCB3aXJlVHlwZSAyID0qLzM0KS5mb3JrKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnBhdGgubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci5pbnQzMihtZXNzYWdlLnBhdGhbaV0pO1xuICAgICAgICAgICAgICAgIHdyaXRlci5sZGVsaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2YgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgaWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2Z9IG1lc3NhZ2UgQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mfSBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2YuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuaWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mKCk7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2V5ID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubGVhZiA9ICRyb290LmljczIzLkxlYWZPcC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UucGF0aCAmJiBtZXNzYWdlLnBhdGgubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGF0aCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wYXRoLnB1c2gocmVhZGVyLmludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGF0aC5wdXNoKHJlYWRlci5pbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZiBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHJldHVybnMge2ljczIzLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZn0gQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZmllcyBhIENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZiBtZXNzYWdlLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZi52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5rZXkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwia2V5XCIpKVxuICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uua2V5ICYmIHR5cGVvZiBtZXNzYWdlLmtleS5sZW5ndGggPT09IFwibnVtYmVyXCIgfHwgJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5rZXkpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwia2V5OiBidWZmZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpKVxuICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UudmFsdWUgJiYgdHlwZW9mIG1lc3NhZ2UudmFsdWUubGVuZ3RoID09PSBcIm51bWJlclwiIHx8ICR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UudmFsdWUpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWU6IGJ1ZmZlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubGVhZiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJsZWFmXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuaWNzMjMuTGVhZk9wLnZlcmlmeShtZXNzYWdlLmxlYWYpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGVhZi5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucGF0aCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwYXRoXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UucGF0aCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInBhdGg6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnBhdGgubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UucGF0aFtpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJwYXRoOiBpbnRlZ2VyW10gZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge2ljczIzLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZn0gQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2YuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuaWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mKVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5pY3MyMy5Db21wcmVzc2VkRXhpc3RlbmNlUHJvb2YoKTtcbiAgICAgICAgICAgIGlmIChvYmplY3Qua2V5ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Qua2V5ID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAkdXRpbC5iYXNlNjQuZGVjb2RlKG9iamVjdC5rZXksIG1lc3NhZ2Uua2V5ID0gJHV0aWwubmV3QnVmZmVyKCR1dGlsLmJhc2U2NC5sZW5ndGgob2JqZWN0LmtleSkpLCAwKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvYmplY3Qua2V5Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5rZXkgPSBvYmplY3Qua2V5O1xuICAgICAgICAgICAgaWYgKG9iamVjdC52YWx1ZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnZhbHVlID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAkdXRpbC5iYXNlNjQuZGVjb2RlKG9iamVjdC52YWx1ZSwgbWVzc2FnZS52YWx1ZSA9ICR1dGlsLm5ld0J1ZmZlcigkdXRpbC5iYXNlNjQubGVuZ3RoKG9iamVjdC52YWx1ZSkpLCAwKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvYmplY3QudmFsdWUubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlID0gb2JqZWN0LnZhbHVlO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5sZWFmICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5sZWFmICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuaWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mLmxlYWY6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmxlYWYgPSAkcm9vdC5pY3MyMy5MZWFmT3AuZnJvbU9iamVjdChvYmplY3QubGVhZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnBhdGgpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuaWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mLnBhdGg6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UucGF0aCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnBhdGgubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGF0aFtpXSA9IG9iamVjdC5wYXRoW2ldIHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2YgbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mfSBtZXNzYWdlIENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZi50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cylcbiAgICAgICAgICAgICAgICBvYmplY3QucGF0aCA9IFtdO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3Qua2V5ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmtleSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieXRlcyAhPT0gQXJyYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Qua2V5ID0gJHV0aWwubmV3QnVmZmVyKG9iamVjdC5rZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3QudmFsdWUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZXMgIT09IEFycmF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gJHV0aWwubmV3QnVmZmVyKG9iamVjdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9iamVjdC5sZWFmID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmtleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJrZXlcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmtleSA9IG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZyA/ICR1dGlsLmJhc2U2NC5lbmNvZGUobWVzc2FnZS5rZXksIDAsIG1lc3NhZ2Uua2V5Lmxlbmd0aCkgOiBvcHRpb25zLmJ5dGVzID09PSBBcnJheSA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG1lc3NhZ2Uua2V5KSA6IG1lc3NhZ2Uua2V5O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidmFsdWVcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gb3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nID8gJHV0aWwuYmFzZTY0LmVuY29kZShtZXNzYWdlLnZhbHVlLCAwLCBtZXNzYWdlLnZhbHVlLmxlbmd0aCkgOiBvcHRpb25zLmJ5dGVzID09PSBBcnJheSA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG1lc3NhZ2UudmFsdWUpIDogbWVzc2FnZS52YWx1ZTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmxlYWYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibGVhZlwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QubGVhZiA9ICRyb290LmljczIzLkxlYWZPcC50b09iamVjdChtZXNzYWdlLmxlYWYsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucGF0aCAmJiBtZXNzYWdlLnBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnBhdGggPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UucGF0aC5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnBhdGhbal0gPSBtZXNzYWdlLnBhdGhbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZiB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZjtcbiAgICB9KSgpO1xuXG4gICAgaWNzMjMuQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mLlxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjNcbiAgICAgICAgICogQGludGVyZmFjZSBJQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7VWludDhBcnJheXxudWxsfSBba2V5XSBDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2Yga2V5XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7aWNzMjMuSUNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZnxudWxsfSBbbGVmdF0gQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mIGxlZnRcbiAgICAgICAgICogQHByb3BlcnR5IHtpY3MyMy5JQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mfG51bGx9IFtyaWdodF0gQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mIHJpZ2h0XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IENvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZi5cbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzXG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIENvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZi5cbiAgICAgICAgICogQGltcGxlbWVudHMgSUNvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2YocHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2Yga2V5LlxuICAgICAgICAgKiBAbWVtYmVyIHtVaW50OEFycmF5fSBrZXlcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZi5wcm90b3R5cGUua2V5ID0gJHV0aWwubmV3QnVmZmVyKFtdKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mIGxlZnQuXG4gICAgICAgICAqIEBtZW1iZXIge2ljczIzLklDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2Z8bnVsbHx1bmRlZmluZWR9IGxlZnRcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZi5wcm90b3R5cGUubGVmdCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZiByaWdodC5cbiAgICAgICAgICogQG1lbWJlciB7aWNzMjMuSUNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZnxudWxsfHVuZGVmaW5lZH0gcmlnaHRcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZi5wcm90b3R5cGUucmlnaHQgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IENvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZiBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSUNvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZj19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mfSBDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2YgaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZi5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2YocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2YgbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgaWNzMjMuQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2Z9IG1lc3NhZ2UgQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5rZXkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwia2V5XCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuYnl0ZXMobWVzc2FnZS5rZXkpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubGVmdCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJsZWZ0XCIpKVxuICAgICAgICAgICAgICAgICRyb290LmljczIzLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZi5lbmNvZGUobWVzc2FnZS5sZWZ0LCB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5yaWdodCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJyaWdodFwiKSlcbiAgICAgICAgICAgICAgICAkcm9vdC5pY3MyMy5Db21wcmVzc2VkRXhpc3RlbmNlUHJvb2YuZW5jb2RlKG1lc3NhZ2UucmlnaHQsIHdyaXRlci51aW50MzIoLyogaWQgMywgd2lyZVR5cGUgMiA9Ki8yNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2YgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgaWNzMjMuQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2Z9IG1lc3NhZ2UgQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mfSBDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2YuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuaWNzMjMuQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mKCk7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2V5ID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5sZWZ0ID0gJHJvb3QuaWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yaWdodCA9ICRyb290LmljczIzLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mfSBDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2YuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGEgQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmtleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJrZXlcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5rZXkgJiYgdHlwZW9mIG1lc3NhZ2Uua2V5Lmxlbmd0aCA9PT0gXCJudW1iZXJcIiB8fCAkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmtleSkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJrZXk6IGJ1ZmZlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubGVmdCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJsZWZ0XCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuaWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mLnZlcmlmeShtZXNzYWdlLmxlZnQpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGVmdC5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucmlnaHQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicmlnaHRcIikpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5pY3MyMy5Db21wcmVzc2VkRXhpc3RlbmNlUHJvb2YudmVyaWZ5KG1lc3NhZ2UucmlnaHQpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicmlnaHQuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge2ljczIzLkNvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZn0gQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2YuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuaWNzMjMuQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mKVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5pY3MyMy5Db21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2YoKTtcbiAgICAgICAgICAgIGlmIChvYmplY3Qua2V5ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Qua2V5ID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAkdXRpbC5iYXNlNjQuZGVjb2RlKG9iamVjdC5rZXksIG1lc3NhZ2Uua2V5ID0gJHV0aWwubmV3QnVmZmVyKCR1dGlsLmJhc2U2NC5sZW5ndGgob2JqZWN0LmtleSkpLCAwKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvYmplY3Qua2V5Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5rZXkgPSBvYmplY3Qua2V5O1xuICAgICAgICAgICAgaWYgKG9iamVjdC5sZWZ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5sZWZ0ICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuaWNzMjMuQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mLmxlZnQ6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmxlZnQgPSAkcm9vdC5pY3MyMy5Db21wcmVzc2VkRXhpc3RlbmNlUHJvb2YuZnJvbU9iamVjdChvYmplY3QubGVmdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LnJpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5yaWdodCAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmljczIzLkNvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZi5yaWdodDogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UucmlnaHQgPSAkcm9vdC5pY3MyMy5Db21wcmVzc2VkRXhpc3RlbmNlUHJvb2YuZnJvbU9iamVjdChvYmplY3QucmlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIENvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZiBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5Db21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2Z9IG1lc3NhZ2UgQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZylcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmtleSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5rZXkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZXMgIT09IEFycmF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmtleSA9ICR1dGlsLm5ld0J1ZmZlcihvYmplY3Qua2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqZWN0LmxlZnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIG9iamVjdC5yaWdodCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5rZXkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwia2V5XCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5rZXkgPSBvcHRpb25zLmJ5dGVzID09PSBTdHJpbmcgPyAkdXRpbC5iYXNlNjQuZW5jb2RlKG1lc3NhZ2Uua2V5LCAwLCBtZXNzYWdlLmtleS5sZW5ndGgpIDogb3B0aW9ucy5ieXRlcyA9PT0gQXJyYXkgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZXNzYWdlLmtleSkgOiBtZXNzYWdlLmtleTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmxlZnQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibGVmdFwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QubGVmdCA9ICRyb290LmljczIzLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZi50b09iamVjdChtZXNzYWdlLmxlZnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucmlnaHQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicmlnaHRcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnJpZ2h0ID0gJHJvb3QuaWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mLnRvT2JqZWN0KG1lc3NhZ2UucmlnaHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2YgdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2YucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2Y7XG4gICAgfSkoKTtcblxuICAgIHJldHVybiBpY3MyMztcbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gJHJvb3Q7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@confio/ics23/build/generated/codecimpl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@confio/ics23/build/ics23.js":
/*!***************************************************!*\
  !*** ./node_modules/@confio/ics23/build/ics23.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.batchVerifyNonMembership = exports.batchVerifyMembership = exports.verifyNonMembership = exports.verifyMembership = void 0;\nconst compress_1 = __webpack_require__(/*! ./compress */ \"(ssr)/./node_modules/@confio/ics23/build/compress.js\");\nconst proofs_1 = __webpack_require__(/*! ./proofs */ \"(ssr)/./node_modules/@confio/ics23/build/proofs.js\");\nconst specs_1 = __webpack_require__(/*! ./specs */ \"(ssr)/./node_modules/@confio/ics23/build/specs.js\");\n/*\nThis implements the client side functions as specified in\nhttps://github.com/cosmos/ics/tree/master/spec/ics-023-vector-commitments\n\nIn particular:\n\n  // Assumes ExistenceProof\n  type verifyMembership = (root: CommitmentRoot, proof: CommitmentProof, key: Key, value: Value) => boolean\n\n  // Assumes NonExistenceProof\n  type verifyNonMembership = (root: CommitmentRoot, proof: CommitmentProof, key: Key) => boolean\n\n  // Assumes BatchProof - required ExistenceProofs may be a subset of all items proven\n  type batchVerifyMembership = (root: CommitmentRoot, proof: CommitmentProof, items: Map<Key, Value>) => boolean\n\n  // Assumes BatchProof - required NonExistenceProofs may be a subset of all items proven\n  type batchVerifyNonMembership = (root: CommitmentRoot, proof: CommitmentProof, keys: Set<Key>) => boolean\n\nWe make an adjustment to accept a Spec to ensure the provided proof is in the format of the expected merkle store.\nThis can avoid an range of attacks on fake preimages, as we need to be careful on how to map key, value -> leaf\nand determine neighbors\n*/\n/**\n * verifyMembership ensures proof is (contains) a valid existence proof for the given\n */\nfunction verifyMembership(proof, spec, root, key, value) {\n    const norm = (0, compress_1.decompress)(proof);\n    const exist = getExistForKey(norm, key);\n    if (!exist) {\n        return false;\n    }\n    try {\n        (0, proofs_1.verifyExistence)(exist, spec, root, key, value);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nexports.verifyMembership = verifyMembership;\n/**\n * verifyNonMembership ensures proof is (contains) a valid non-existence proof for the given key\n */\nfunction verifyNonMembership(proof, spec, root, key) {\n    const norm = (0, compress_1.decompress)(proof);\n    const nonexist = getNonExistForKey(norm, key);\n    if (!nonexist) {\n        return false;\n    }\n    try {\n        (0, proofs_1.verifyNonExistence)(nonexist, spec, root, key);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nexports.verifyNonMembership = verifyNonMembership;\n/**\n * batchVerifyMembership ensures proof is (contains) a valid existence proof for the given\n */\nfunction batchVerifyMembership(proof, spec, root, items) {\n    const norm = (0, compress_1.decompress)(proof);\n    for (const [key, value] of items.entries()) {\n        if (!verifyMembership(norm, spec, root, key, value)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.batchVerifyMembership = batchVerifyMembership;\n/**\n * batchVerifyNonMembership ensures proof is (contains) a valid existence proof for the given\n */\nfunction batchVerifyNonMembership(proof, spec, root, keys) {\n    const norm = (0, compress_1.decompress)(proof);\n    for (const key of keys) {\n        if (!verifyNonMembership(norm, spec, root, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.batchVerifyNonMembership = batchVerifyNonMembership;\nfunction getExistForKey(proof, key) {\n    const match = (p) => !!p && (0, specs_1.bytesEqual)(key, p.key);\n    if (match(proof.exist)) {\n        return proof.exist;\n    }\n    else if (proof.batch) {\n        return proof.batch.entries.map((x) => x.exist || null).find(match);\n    }\n    return undefined;\n}\nfunction getNonExistForKey(proof, key) {\n    const match = (p) => {\n        return (!!p &&\n            (!p.left || (0, specs_1.bytesBefore)(p.left.key, key)) &&\n            (!p.right || (0, specs_1.bytesBefore)(key, p.right.key)));\n    };\n    if (match(proof.nonexist)) {\n        return proof.nonexist;\n    }\n    else if (proof.batch) {\n        return proof.batch.entries.map((x) => x.nonexist || null).find(match);\n    }\n    return undefined;\n}\n//# sourceMappingURL=ics23.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbmZpby9pY3MyMy9idWlsZC9pY3MyMy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0MsR0FBRyw2QkFBNkIsR0FBRywyQkFBMkIsR0FBRyx3QkFBd0I7QUFDekgsbUJBQW1CLG1CQUFPLENBQUMsd0VBQVk7QUFDdkMsaUJBQWlCLG1CQUFPLENBQUMsb0VBQVU7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsa0VBQVM7QUFDakM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW4tcHJvLW5leHQvLi9ub2RlX21vZHVsZXMvQGNvbmZpby9pY3MyMy9idWlsZC9pY3MyMy5qcz81MzM3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5iYXRjaFZlcmlmeU5vbk1lbWJlcnNoaXAgPSBleHBvcnRzLmJhdGNoVmVyaWZ5TWVtYmVyc2hpcCA9IGV4cG9ydHMudmVyaWZ5Tm9uTWVtYmVyc2hpcCA9IGV4cG9ydHMudmVyaWZ5TWVtYmVyc2hpcCA9IHZvaWQgMDtcbmNvbnN0IGNvbXByZXNzXzEgPSByZXF1aXJlKFwiLi9jb21wcmVzc1wiKTtcbmNvbnN0IHByb29mc18xID0gcmVxdWlyZShcIi4vcHJvb2ZzXCIpO1xuY29uc3Qgc3BlY3NfMSA9IHJlcXVpcmUoXCIuL3NwZWNzXCIpO1xuLypcblRoaXMgaW1wbGVtZW50cyB0aGUgY2xpZW50IHNpZGUgZnVuY3Rpb25zIGFzIHNwZWNpZmllZCBpblxuaHR0cHM6Ly9naXRodWIuY29tL2Nvc21vcy9pY3MvdHJlZS9tYXN0ZXIvc3BlYy9pY3MtMDIzLXZlY3Rvci1jb21taXRtZW50c1xuXG5JbiBwYXJ0aWN1bGFyOlxuXG4gIC8vIEFzc3VtZXMgRXhpc3RlbmNlUHJvb2ZcbiAgdHlwZSB2ZXJpZnlNZW1iZXJzaGlwID0gKHJvb3Q6IENvbW1pdG1lbnRSb290LCBwcm9vZjogQ29tbWl0bWVudFByb29mLCBrZXk6IEtleSwgdmFsdWU6IFZhbHVlKSA9PiBib29sZWFuXG5cbiAgLy8gQXNzdW1lcyBOb25FeGlzdGVuY2VQcm9vZlxuICB0eXBlIHZlcmlmeU5vbk1lbWJlcnNoaXAgPSAocm9vdDogQ29tbWl0bWVudFJvb3QsIHByb29mOiBDb21taXRtZW50UHJvb2YsIGtleTogS2V5KSA9PiBib29sZWFuXG5cbiAgLy8gQXNzdW1lcyBCYXRjaFByb29mIC0gcmVxdWlyZWQgRXhpc3RlbmNlUHJvb2ZzIG1heSBiZSBhIHN1YnNldCBvZiBhbGwgaXRlbXMgcHJvdmVuXG4gIHR5cGUgYmF0Y2hWZXJpZnlNZW1iZXJzaGlwID0gKHJvb3Q6IENvbW1pdG1lbnRSb290LCBwcm9vZjogQ29tbWl0bWVudFByb29mLCBpdGVtczogTWFwPEtleSwgVmFsdWU+KSA9PiBib29sZWFuXG5cbiAgLy8gQXNzdW1lcyBCYXRjaFByb29mIC0gcmVxdWlyZWQgTm9uRXhpc3RlbmNlUHJvb2ZzIG1heSBiZSBhIHN1YnNldCBvZiBhbGwgaXRlbXMgcHJvdmVuXG4gIHR5cGUgYmF0Y2hWZXJpZnlOb25NZW1iZXJzaGlwID0gKHJvb3Q6IENvbW1pdG1lbnRSb290LCBwcm9vZjogQ29tbWl0bWVudFByb29mLCBrZXlzOiBTZXQ8S2V5PikgPT4gYm9vbGVhblxuXG5XZSBtYWtlIGFuIGFkanVzdG1lbnQgdG8gYWNjZXB0IGEgU3BlYyB0byBlbnN1cmUgdGhlIHByb3ZpZGVkIHByb29mIGlzIGluIHRoZSBmb3JtYXQgb2YgdGhlIGV4cGVjdGVkIG1lcmtsZSBzdG9yZS5cblRoaXMgY2FuIGF2b2lkIGFuIHJhbmdlIG9mIGF0dGFja3Mgb24gZmFrZSBwcmVpbWFnZXMsIGFzIHdlIG5lZWQgdG8gYmUgY2FyZWZ1bCBvbiBob3cgdG8gbWFwIGtleSwgdmFsdWUgLT4gbGVhZlxuYW5kIGRldGVybWluZSBuZWlnaGJvcnNcbiovXG4vKipcbiAqIHZlcmlmeU1lbWJlcnNoaXAgZW5zdXJlcyBwcm9vZiBpcyAoY29udGFpbnMpIGEgdmFsaWQgZXhpc3RlbmNlIHByb29mIGZvciB0aGUgZ2l2ZW5cbiAqL1xuZnVuY3Rpb24gdmVyaWZ5TWVtYmVyc2hpcChwcm9vZiwgc3BlYywgcm9vdCwga2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IG5vcm0gPSAoMCwgY29tcHJlc3NfMS5kZWNvbXByZXNzKShwcm9vZik7XG4gICAgY29uc3QgZXhpc3QgPSBnZXRFeGlzdEZvcktleShub3JtLCBrZXkpO1xuICAgIGlmICghZXhpc3QpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAoMCwgcHJvb2ZzXzEudmVyaWZ5RXhpc3RlbmNlKShleGlzdCwgc3BlYywgcm9vdCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMudmVyaWZ5TWVtYmVyc2hpcCA9IHZlcmlmeU1lbWJlcnNoaXA7XG4vKipcbiAqIHZlcmlmeU5vbk1lbWJlcnNoaXAgZW5zdXJlcyBwcm9vZiBpcyAoY29udGFpbnMpIGEgdmFsaWQgbm9uLWV4aXN0ZW5jZSBwcm9vZiBmb3IgdGhlIGdpdmVuIGtleVxuICovXG5mdW5jdGlvbiB2ZXJpZnlOb25NZW1iZXJzaGlwKHByb29mLCBzcGVjLCByb290LCBrZXkpIHtcbiAgICBjb25zdCBub3JtID0gKDAsIGNvbXByZXNzXzEuZGVjb21wcmVzcykocHJvb2YpO1xuICAgIGNvbnN0IG5vbmV4aXN0ID0gZ2V0Tm9uRXhpc3RGb3JLZXkobm9ybSwga2V5KTtcbiAgICBpZiAoIW5vbmV4aXN0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgKDAsIHByb29mc18xLnZlcmlmeU5vbkV4aXN0ZW5jZSkobm9uZXhpc3QsIHNwZWMsIHJvb3QsIGtleSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMudmVyaWZ5Tm9uTWVtYmVyc2hpcCA9IHZlcmlmeU5vbk1lbWJlcnNoaXA7XG4vKipcbiAqIGJhdGNoVmVyaWZ5TWVtYmVyc2hpcCBlbnN1cmVzIHByb29mIGlzIChjb250YWlucykgYSB2YWxpZCBleGlzdGVuY2UgcHJvb2YgZm9yIHRoZSBnaXZlblxuICovXG5mdW5jdGlvbiBiYXRjaFZlcmlmeU1lbWJlcnNoaXAocHJvb2YsIHNwZWMsIHJvb3QsIGl0ZW1zKSB7XG4gICAgY29uc3Qgbm9ybSA9ICgwLCBjb21wcmVzc18xLmRlY29tcHJlc3MpKHByb29mKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBpdGVtcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgaWYgKCF2ZXJpZnlNZW1iZXJzaGlwKG5vcm0sIHNwZWMsIHJvb3QsIGtleSwgdmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmJhdGNoVmVyaWZ5TWVtYmVyc2hpcCA9IGJhdGNoVmVyaWZ5TWVtYmVyc2hpcDtcbi8qKlxuICogYmF0Y2hWZXJpZnlOb25NZW1iZXJzaGlwIGVuc3VyZXMgcHJvb2YgaXMgKGNvbnRhaW5zKSBhIHZhbGlkIGV4aXN0ZW5jZSBwcm9vZiBmb3IgdGhlIGdpdmVuXG4gKi9cbmZ1bmN0aW9uIGJhdGNoVmVyaWZ5Tm9uTWVtYmVyc2hpcChwcm9vZiwgc3BlYywgcm9vdCwga2V5cykge1xuICAgIGNvbnN0IG5vcm0gPSAoMCwgY29tcHJlc3NfMS5kZWNvbXByZXNzKShwcm9vZik7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBpZiAoIXZlcmlmeU5vbk1lbWJlcnNoaXAobm9ybSwgc3BlYywgcm9vdCwga2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5iYXRjaFZlcmlmeU5vbk1lbWJlcnNoaXAgPSBiYXRjaFZlcmlmeU5vbk1lbWJlcnNoaXA7XG5mdW5jdGlvbiBnZXRFeGlzdEZvcktleShwcm9vZiwga2V5KSB7XG4gICAgY29uc3QgbWF0Y2ggPSAocCkgPT4gISFwICYmICgwLCBzcGVjc18xLmJ5dGVzRXF1YWwpKGtleSwgcC5rZXkpO1xuICAgIGlmIChtYXRjaChwcm9vZi5leGlzdCkpIHtcbiAgICAgICAgcmV0dXJuIHByb29mLmV4aXN0O1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9vZi5iYXRjaCkge1xuICAgICAgICByZXR1cm4gcHJvb2YuYmF0Y2guZW50cmllcy5tYXAoKHgpID0+IHguZXhpc3QgfHwgbnVsbCkuZmluZChtYXRjaCk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBnZXROb25FeGlzdEZvcktleShwcm9vZiwga2V5KSB7XG4gICAgY29uc3QgbWF0Y2ggPSAocCkgPT4ge1xuICAgICAgICByZXR1cm4gKCEhcCAmJlxuICAgICAgICAgICAgKCFwLmxlZnQgfHwgKDAsIHNwZWNzXzEuYnl0ZXNCZWZvcmUpKHAubGVmdC5rZXksIGtleSkpICYmXG4gICAgICAgICAgICAoIXAucmlnaHQgfHwgKDAsIHNwZWNzXzEuYnl0ZXNCZWZvcmUpKGtleSwgcC5yaWdodC5rZXkpKSk7XG4gICAgfTtcbiAgICBpZiAobWF0Y2gocHJvb2Yubm9uZXhpc3QpKSB7XG4gICAgICAgIHJldHVybiBwcm9vZi5ub25leGlzdDtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvb2YuYmF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHByb29mLmJhdGNoLmVudHJpZXMubWFwKCh4KSA9PiB4Lm5vbmV4aXN0IHx8IG51bGwpLmZpbmQobWF0Y2gpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWNzMjMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@confio/ics23/build/ics23.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@confio/ics23/build/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@confio/ics23/build/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.verifyNonExistence = exports.verifyExistence = exports.tendermintSpec = exports.iavlSpec = exports.calculateExistenceRoot = exports.verifyNonMembership = exports.verifyMembership = exports.ics23 = void 0;\nvar codecimpl_1 = __webpack_require__(/*! ./generated/codecimpl */ \"(ssr)/./node_modules/@confio/ics23/build/generated/codecimpl.js\");\nObject.defineProperty(exports, \"ics23\", ({ enumerable: true, get: function () { return codecimpl_1.ics23; } }));\nvar ics23_1 = __webpack_require__(/*! ./ics23 */ \"(ssr)/./node_modules/@confio/ics23/build/ics23.js\");\nObject.defineProperty(exports, \"verifyMembership\", ({ enumerable: true, get: function () { return ics23_1.verifyMembership; } }));\nObject.defineProperty(exports, \"verifyNonMembership\", ({ enumerable: true, get: function () { return ics23_1.verifyNonMembership; } }));\nvar proofs_1 = __webpack_require__(/*! ./proofs */ \"(ssr)/./node_modules/@confio/ics23/build/proofs.js\");\nObject.defineProperty(exports, \"calculateExistenceRoot\", ({ enumerable: true, get: function () { return proofs_1.calculateExistenceRoot; } }));\nObject.defineProperty(exports, \"iavlSpec\", ({ enumerable: true, get: function () { return proofs_1.iavlSpec; } }));\nObject.defineProperty(exports, \"tendermintSpec\", ({ enumerable: true, get: function () { return proofs_1.tendermintSpec; } }));\nObject.defineProperty(exports, \"verifyExistence\", ({ enumerable: true, get: function () { return proofs_1.verifyExistence; } }));\nObject.defineProperty(exports, \"verifyNonExistence\", ({ enumerable: true, get: function () { return proofs_1.verifyNonExistence; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbmZpby9pY3MyMy9idWlsZC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsR0FBRyx1QkFBdUIsR0FBRyxzQkFBc0IsR0FBRyxnQkFBZ0IsR0FBRyw4QkFBOEIsR0FBRywyQkFBMkIsR0FBRyx3QkFBd0IsR0FBRyxhQUFhO0FBQzFNLGtCQUFrQixtQkFBTyxDQUFDLDhGQUF1QjtBQUNqRCx5Q0FBd0MsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDN0csY0FBYyxtQkFBTyxDQUFDLGtFQUFTO0FBQy9CLG9EQUFtRCxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUMvSCx1REFBc0QsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDckksZUFBZSxtQkFBTyxDQUFDLG9FQUFVO0FBQ2pDLDBEQUF5RCxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUM1SSw0Q0FBMkMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDaEgsa0RBQWlELEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQzVILG1EQUFrRCxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUM5SCxzREFBcUQsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDcEkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVuLXByby1uZXh0Ly4vbm9kZV9tb2R1bGVzL0Bjb25maW8vaWNzMjMvYnVpbGQvaW5kZXguanM/MTJiNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmVyaWZ5Tm9uRXhpc3RlbmNlID0gZXhwb3J0cy52ZXJpZnlFeGlzdGVuY2UgPSBleHBvcnRzLnRlbmRlcm1pbnRTcGVjID0gZXhwb3J0cy5pYXZsU3BlYyA9IGV4cG9ydHMuY2FsY3VsYXRlRXhpc3RlbmNlUm9vdCA9IGV4cG9ydHMudmVyaWZ5Tm9uTWVtYmVyc2hpcCA9IGV4cG9ydHMudmVyaWZ5TWVtYmVyc2hpcCA9IGV4cG9ydHMuaWNzMjMgPSB2b2lkIDA7XG52YXIgY29kZWNpbXBsXzEgPSByZXF1aXJlKFwiLi9nZW5lcmF0ZWQvY29kZWNpbXBsXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaWNzMjNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVjaW1wbF8xLmljczIzOyB9IH0pO1xudmFyIGljczIzXzEgPSByZXF1aXJlKFwiLi9pY3MyM1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZlcmlmeU1lbWJlcnNoaXBcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGljczIzXzEudmVyaWZ5TWVtYmVyc2hpcDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZlcmlmeU5vbk1lbWJlcnNoaXBcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGljczIzXzEudmVyaWZ5Tm9uTWVtYmVyc2hpcDsgfSB9KTtcbnZhciBwcm9vZnNfMSA9IHJlcXVpcmUoXCIuL3Byb29mc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNhbGN1bGF0ZUV4aXN0ZW5jZVJvb3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb29mc18xLmNhbGN1bGF0ZUV4aXN0ZW5jZVJvb3Q7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpYXZsU3BlY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvb2ZzXzEuaWF2bFNwZWM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0ZW5kZXJtaW50U3BlY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvb2ZzXzEudGVuZGVybWludFNwZWM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2ZXJpZnlFeGlzdGVuY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb29mc18xLnZlcmlmeUV4aXN0ZW5jZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZlcmlmeU5vbkV4aXN0ZW5jZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvb2ZzXzEudmVyaWZ5Tm9uRXhpc3RlbmNlOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@confio/ics23/build/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@confio/ics23/build/ops.js":
/*!*************************************************!*\
  !*** ./node_modules/@confio/ics23/build/ops.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.doHash = exports.applyInner = exports.applyLeaf = void 0;\nconst ripemd160_1 = __webpack_require__(/*! @noble/hashes/ripemd160 */ \"(ssr)/./node_modules/@noble/hashes/ripemd160.js\");\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/sha256.js\");\nconst sha512_1 = __webpack_require__(/*! @noble/hashes/sha512 */ \"(ssr)/./node_modules/@noble/hashes/sha512.js\");\nconst codecimpl_1 = __webpack_require__(/*! ./generated/codecimpl */ \"(ssr)/./node_modules/@confio/ics23/build/generated/codecimpl.js\");\nfunction applyLeaf(leaf, key, value) {\n    if (key.length === 0) {\n        throw new Error(\"Missing key\");\n    }\n    if (value.length === 0) {\n        throw new Error(\"Missing value\");\n    }\n    const pkey = prepareLeafData(ensureHash(leaf.prehashKey), ensureLength(leaf.length), key);\n    const pvalue = prepareLeafData(ensureHash(leaf.prehashValue), ensureLength(leaf.length), value);\n    const data = new Uint8Array([\n        ...ensureBytes(leaf.prefix),\n        ...pkey,\n        ...pvalue,\n    ]);\n    return doHash(ensureHash(leaf.hash), data);\n}\nexports.applyLeaf = applyLeaf;\nfunction applyInner(inner, child) {\n    if (child.length === 0) {\n        throw new Error(\"Inner op needs child value\");\n    }\n    const preimage = new Uint8Array([\n        ...ensureBytes(inner.prefix),\n        ...child,\n        ...ensureBytes(inner.suffix),\n    ]);\n    return doHash(ensureHash(inner.hash), preimage);\n}\nexports.applyInner = applyInner;\nfunction ensure(maybe, value) {\n    return maybe === undefined || maybe === null ? value : maybe;\n}\nconst ensureHash = (h) => ensure(h, codecimpl_1.ics23.HashOp.NO_HASH);\nconst ensureLength = (l) => ensure(l, codecimpl_1.ics23.LengthOp.NO_PREFIX);\nconst ensureBytes = (b) => ensure(b, new Uint8Array([]));\nfunction prepareLeafData(hashOp, lengthOp, data) {\n    const h = doHashOrNoop(hashOp, data);\n    return doLengthOp(lengthOp, h);\n}\n// doHashOrNoop will return the preimage untouched if hashOp == NONE,\n// otherwise, perform doHash\nfunction doHashOrNoop(hashOp, preimage) {\n    if (hashOp === codecimpl_1.ics23.HashOp.NO_HASH) {\n        return preimage;\n    }\n    return doHash(hashOp, preimage);\n}\n// doHash will preform the specified hash on the preimage.\n// if hashOp == NONE, it will return an error (use doHashOrNoop if you want different behavior)\nfunction doHash(hashOp, preimage) {\n    switch (hashOp) {\n        case codecimpl_1.ics23.HashOp.SHA256:\n            return (0, sha256_1.sha256)(preimage);\n        case codecimpl_1.ics23.HashOp.SHA512:\n            return (0, sha512_1.sha512)(preimage);\n        case codecimpl_1.ics23.HashOp.RIPEMD160:\n            return (0, ripemd160_1.ripemd160)(preimage);\n        case codecimpl_1.ics23.HashOp.BITCOIN:\n            return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(preimage));\n        case codecimpl_1.ics23.HashOp.SHA512_256:\n            return (0, sha512_1.sha512_256)(preimage);\n    }\n    throw new Error(`Unsupported hashop: ${hashOp}`);\n}\nexports.doHash = doHash;\n// doLengthOp will calculate the proper prefix and return it prepended\n//   doLengthOp(op, data) -> length(data) || data\nfunction doLengthOp(lengthOp, data) {\n    switch (lengthOp) {\n        case codecimpl_1.ics23.LengthOp.NO_PREFIX:\n            return data;\n        case codecimpl_1.ics23.LengthOp.VAR_PROTO:\n            return new Uint8Array([...encodeVarintProto(data.length), ...data]);\n        case codecimpl_1.ics23.LengthOp.REQUIRE_32_BYTES:\n            if (data.length !== 32) {\n                throw new Error(`Length is ${data.length}, not 32 bytes`);\n            }\n            return data;\n        case codecimpl_1.ics23.LengthOp.REQUIRE_64_BYTES:\n            if (data.length !== 64) {\n                throw new Error(`Length is ${data.length}, not 64 bytes`);\n            }\n            return data;\n        case codecimpl_1.ics23.LengthOp.FIXED32_LITTLE:\n            return new Uint8Array([...encodeFixed32Le(data.length), ...data]);\n        // TODO\n        // case LengthOp_VAR_RLP:\n        // case LengthOp_FIXED32_BIG:\n        // case LengthOp_FIXED64_BIG:\n        // case LengthOp_FIXED64_LITTLE:\n    }\n    throw new Error(`Unsupported lengthop: ${lengthOp}`);\n}\nfunction encodeVarintProto(n) {\n    let enc = [];\n    let l = n;\n    while (l >= 128) {\n        const b = (l % 128) + 128;\n        enc = [...enc, b];\n        l = l / 128;\n    }\n    enc = [...enc, l];\n    return new Uint8Array(enc);\n}\nfunction encodeFixed32Le(n) {\n    const enc = new Uint8Array(4);\n    let l = n;\n    for (let i = enc.length; i > 0; i--) {\n        enc[Math.abs(i - enc.length)] = l % 256;\n        l = Math.floor(l / 256);\n    }\n    return enc;\n}\n//# sourceMappingURL=ops.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbmZpby9pY3MyMy9idWlsZC9vcHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLGtCQUFrQixHQUFHLGlCQUFpQjtBQUN2RCxvQkFBb0IsbUJBQU8sQ0FBQyxnRkFBeUI7QUFDckQsaUJBQWlCLG1CQUFPLENBQUMsMEVBQXNCO0FBQy9DLGlCQUFpQixtQkFBTyxDQUFDLDBFQUFzQjtBQUMvQyxvQkFBb0IsbUJBQU8sQ0FBQyw4RkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxZQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVuLXByby1uZXh0Ly4vbm9kZV9tb2R1bGVzL0Bjb25maW8vaWNzMjMvYnVpbGQvb3BzLmpzPzRmMjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRvSGFzaCA9IGV4cG9ydHMuYXBwbHlJbm5lciA9IGV4cG9ydHMuYXBwbHlMZWFmID0gdm9pZCAwO1xuY29uc3QgcmlwZW1kMTYwXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9yaXBlbWQxNjBcIik7XG5jb25zdCBzaGEyNTZfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiKTtcbmNvbnN0IHNoYTUxMl8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhNTEyXCIpO1xuY29uc3QgY29kZWNpbXBsXzEgPSByZXF1aXJlKFwiLi9nZW5lcmF0ZWQvY29kZWNpbXBsXCIpO1xuZnVuY3Rpb24gYXBwbHlMZWFmKGxlYWYsIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGtleVwiKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlXCIpO1xuICAgIH1cbiAgICBjb25zdCBwa2V5ID0gcHJlcGFyZUxlYWZEYXRhKGVuc3VyZUhhc2gobGVhZi5wcmVoYXNoS2V5KSwgZW5zdXJlTGVuZ3RoKGxlYWYubGVuZ3RoKSwga2V5KTtcbiAgICBjb25zdCBwdmFsdWUgPSBwcmVwYXJlTGVhZkRhdGEoZW5zdXJlSGFzaChsZWFmLnByZWhhc2hWYWx1ZSksIGVuc3VyZUxlbmd0aChsZWFmLmxlbmd0aCksIHZhbHVlKTtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAuLi5lbnN1cmVCeXRlcyhsZWFmLnByZWZpeCksXG4gICAgICAgIC4uLnBrZXksXG4gICAgICAgIC4uLnB2YWx1ZSxcbiAgICBdKTtcbiAgICByZXR1cm4gZG9IYXNoKGVuc3VyZUhhc2gobGVhZi5oYXNoKSwgZGF0YSk7XG59XG5leHBvcnRzLmFwcGx5TGVhZiA9IGFwcGx5TGVhZjtcbmZ1bmN0aW9uIGFwcGx5SW5uZXIoaW5uZXIsIGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbm5lciBvcCBuZWVkcyBjaGlsZCB2YWx1ZVwiKTtcbiAgICB9XG4gICAgY29uc3QgcHJlaW1hZ2UgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgIC4uLmVuc3VyZUJ5dGVzKGlubmVyLnByZWZpeCksXG4gICAgICAgIC4uLmNoaWxkLFxuICAgICAgICAuLi5lbnN1cmVCeXRlcyhpbm5lci5zdWZmaXgpLFxuICAgIF0pO1xuICAgIHJldHVybiBkb0hhc2goZW5zdXJlSGFzaChpbm5lci5oYXNoKSwgcHJlaW1hZ2UpO1xufVxuZXhwb3J0cy5hcHBseUlubmVyID0gYXBwbHlJbm5lcjtcbmZ1bmN0aW9uIGVuc3VyZShtYXliZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gbWF5YmUgPT09IHVuZGVmaW5lZCB8fCBtYXliZSA9PT0gbnVsbCA/IHZhbHVlIDogbWF5YmU7XG59XG5jb25zdCBlbnN1cmVIYXNoID0gKGgpID0+IGVuc3VyZShoLCBjb2RlY2ltcGxfMS5pY3MyMy5IYXNoT3AuTk9fSEFTSCk7XG5jb25zdCBlbnN1cmVMZW5ndGggPSAobCkgPT4gZW5zdXJlKGwsIGNvZGVjaW1wbF8xLmljczIzLkxlbmd0aE9wLk5PX1BSRUZJWCk7XG5jb25zdCBlbnN1cmVCeXRlcyA9IChiKSA9PiBlbnN1cmUoYiwgbmV3IFVpbnQ4QXJyYXkoW10pKTtcbmZ1bmN0aW9uIHByZXBhcmVMZWFmRGF0YShoYXNoT3AsIGxlbmd0aE9wLCBkYXRhKSB7XG4gICAgY29uc3QgaCA9IGRvSGFzaE9yTm9vcChoYXNoT3AsIGRhdGEpO1xuICAgIHJldHVybiBkb0xlbmd0aE9wKGxlbmd0aE9wLCBoKTtcbn1cbi8vIGRvSGFzaE9yTm9vcCB3aWxsIHJldHVybiB0aGUgcHJlaW1hZ2UgdW50b3VjaGVkIGlmIGhhc2hPcCA9PSBOT05FLFxuLy8gb3RoZXJ3aXNlLCBwZXJmb3JtIGRvSGFzaFxuZnVuY3Rpb24gZG9IYXNoT3JOb29wKGhhc2hPcCwgcHJlaW1hZ2UpIHtcbiAgICBpZiAoaGFzaE9wID09PSBjb2RlY2ltcGxfMS5pY3MyMy5IYXNoT3AuTk9fSEFTSCkge1xuICAgICAgICByZXR1cm4gcHJlaW1hZ2U7XG4gICAgfVxuICAgIHJldHVybiBkb0hhc2goaGFzaE9wLCBwcmVpbWFnZSk7XG59XG4vLyBkb0hhc2ggd2lsbCBwcmVmb3JtIHRoZSBzcGVjaWZpZWQgaGFzaCBvbiB0aGUgcHJlaW1hZ2UuXG4vLyBpZiBoYXNoT3AgPT0gTk9ORSwgaXQgd2lsbCByZXR1cm4gYW4gZXJyb3IgKHVzZSBkb0hhc2hPck5vb3AgaWYgeW91IHdhbnQgZGlmZmVyZW50IGJlaGF2aW9yKVxuZnVuY3Rpb24gZG9IYXNoKGhhc2hPcCwgcHJlaW1hZ2UpIHtcbiAgICBzd2l0Y2ggKGhhc2hPcCkge1xuICAgICAgICBjYXNlIGNvZGVjaW1wbF8xLmljczIzLkhhc2hPcC5TSEEyNTY6XG4gICAgICAgICAgICByZXR1cm4gKDAsIHNoYTI1Nl8xLnNoYTI1NikocHJlaW1hZ2UpO1xuICAgICAgICBjYXNlIGNvZGVjaW1wbF8xLmljczIzLkhhc2hPcC5TSEE1MTI6XG4gICAgICAgICAgICByZXR1cm4gKDAsIHNoYTUxMl8xLnNoYTUxMikocHJlaW1hZ2UpO1xuICAgICAgICBjYXNlIGNvZGVjaW1wbF8xLmljczIzLkhhc2hPcC5SSVBFTUQxNjA6XG4gICAgICAgICAgICByZXR1cm4gKDAsIHJpcGVtZDE2MF8xLnJpcGVtZDE2MCkocHJlaW1hZ2UpO1xuICAgICAgICBjYXNlIGNvZGVjaW1wbF8xLmljczIzLkhhc2hPcC5CSVRDT0lOOlxuICAgICAgICAgICAgcmV0dXJuICgwLCByaXBlbWQxNjBfMS5yaXBlbWQxNjApKCgwLCBzaGEyNTZfMS5zaGEyNTYpKHByZWltYWdlKSk7XG4gICAgICAgIGNhc2UgY29kZWNpbXBsXzEuaWNzMjMuSGFzaE9wLlNIQTUxMl8yNTY6XG4gICAgICAgICAgICByZXR1cm4gKDAsIHNoYTUxMl8xLnNoYTUxMl8yNTYpKHByZWltYWdlKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBoYXNob3A6ICR7aGFzaE9wfWApO1xufVxuZXhwb3J0cy5kb0hhc2ggPSBkb0hhc2g7XG4vLyBkb0xlbmd0aE9wIHdpbGwgY2FsY3VsYXRlIHRoZSBwcm9wZXIgcHJlZml4IGFuZCByZXR1cm4gaXQgcHJlcGVuZGVkXG4vLyAgIGRvTGVuZ3RoT3Aob3AsIGRhdGEpIC0+IGxlbmd0aChkYXRhKSB8fCBkYXRhXG5mdW5jdGlvbiBkb0xlbmd0aE9wKGxlbmd0aE9wLCBkYXRhKSB7XG4gICAgc3dpdGNoIChsZW5ndGhPcCkge1xuICAgICAgICBjYXNlIGNvZGVjaW1wbF8xLmljczIzLkxlbmd0aE9wLk5PX1BSRUZJWDpcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICBjYXNlIGNvZGVjaW1wbF8xLmljczIzLkxlbmd0aE9wLlZBUl9QUk9UTzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbLi4uZW5jb2RlVmFyaW50UHJvdG8oZGF0YS5sZW5ndGgpLCAuLi5kYXRhXSk7XG4gICAgICAgIGNhc2UgY29kZWNpbXBsXzEuaWNzMjMuTGVuZ3RoT3AuUkVRVUlSRV8zMl9CWVRFUzpcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExlbmd0aCBpcyAke2RhdGEubGVuZ3RofSwgbm90IDMyIGJ5dGVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgY2FzZSBjb2RlY2ltcGxfMS5pY3MyMy5MZW5ndGhPcC5SRVFVSVJFXzY0X0JZVEVTOlxuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSA2NCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGVuZ3RoIGlzICR7ZGF0YS5sZW5ndGh9LCBub3QgNjQgYnl0ZXNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICBjYXNlIGNvZGVjaW1wbF8xLmljczIzLkxlbmd0aE9wLkZJWEVEMzJfTElUVExFOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsuLi5lbmNvZGVGaXhlZDMyTGUoZGF0YS5sZW5ndGgpLCAuLi5kYXRhXSk7XG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gY2FzZSBMZW5ndGhPcF9WQVJfUkxQOlxuICAgICAgICAvLyBjYXNlIExlbmd0aE9wX0ZJWEVEMzJfQklHOlxuICAgICAgICAvLyBjYXNlIExlbmd0aE9wX0ZJWEVENjRfQklHOlxuICAgICAgICAvLyBjYXNlIExlbmd0aE9wX0ZJWEVENjRfTElUVExFOlxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGxlbmd0aG9wOiAke2xlbmd0aE9wfWApO1xufVxuZnVuY3Rpb24gZW5jb2RlVmFyaW50UHJvdG8obikge1xuICAgIGxldCBlbmMgPSBbXTtcbiAgICBsZXQgbCA9IG47XG4gICAgd2hpbGUgKGwgPj0gMTI4KSB7XG4gICAgICAgIGNvbnN0IGIgPSAobCAlIDEyOCkgKyAxMjg7XG4gICAgICAgIGVuYyA9IFsuLi5lbmMsIGJdO1xuICAgICAgICBsID0gbCAvIDEyODtcbiAgICB9XG4gICAgZW5jID0gWy4uLmVuYywgbF07XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGVuYyk7XG59XG5mdW5jdGlvbiBlbmNvZGVGaXhlZDMyTGUobikge1xuICAgIGNvbnN0IGVuYyA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGxldCBsID0gbjtcbiAgICBmb3IgKGxldCBpID0gZW5jLmxlbmd0aDsgaSA+IDA7IGktLSkge1xuICAgICAgICBlbmNbTWF0aC5hYnMoaSAtIGVuYy5sZW5ndGgpXSA9IGwgJSAyNTY7XG4gICAgICAgIGwgPSBNYXRoLmZsb29yKGwgLyAyNTYpO1xuICAgIH1cbiAgICByZXR1cm4gZW5jO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3BzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@confio/ics23/build/ops.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@confio/ics23/build/proofs.js":
/*!****************************************************!*\
  !*** ./node_modules/@confio/ics23/build/proofs.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ensureLeftNeighbor = exports.ensureSpec = exports.calculateExistenceRoot = exports.verifyNonExistence = exports.verifyExistence = exports.smtSpec = exports.tendermintSpec = exports.iavlSpec = void 0;\nconst codecimpl_1 = __webpack_require__(/*! ./generated/codecimpl */ \"(ssr)/./node_modules/@confio/ics23/build/generated/codecimpl.js\");\nconst ops_1 = __webpack_require__(/*! ./ops */ \"(ssr)/./node_modules/@confio/ics23/build/ops.js\");\nconst specs_1 = __webpack_require__(/*! ./specs */ \"(ssr)/./node_modules/@confio/ics23/build/specs.js\");\nexports.iavlSpec = {\n    leafSpec: {\n        prefix: Uint8Array.from([0]),\n        hash: codecimpl_1.ics23.HashOp.SHA256,\n        prehashValue: codecimpl_1.ics23.HashOp.SHA256,\n        prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,\n        length: codecimpl_1.ics23.LengthOp.VAR_PROTO,\n    },\n    innerSpec: {\n        childOrder: [0, 1],\n        minPrefixLength: 4,\n        maxPrefixLength: 12,\n        childSize: 33,\n        hash: codecimpl_1.ics23.HashOp.SHA256,\n    },\n};\nexports.tendermintSpec = {\n    leafSpec: {\n        prefix: Uint8Array.from([0]),\n        hash: codecimpl_1.ics23.HashOp.SHA256,\n        prehashValue: codecimpl_1.ics23.HashOp.SHA256,\n        prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,\n        length: codecimpl_1.ics23.LengthOp.VAR_PROTO,\n    },\n    innerSpec: {\n        childOrder: [0, 1],\n        minPrefixLength: 1,\n        maxPrefixLength: 1,\n        childSize: 32,\n        hash: codecimpl_1.ics23.HashOp.SHA256,\n    },\n};\nexports.smtSpec = {\n    leafSpec: {\n        hash: codecimpl_1.ics23.HashOp.SHA256,\n        prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,\n        prehashValue: codecimpl_1.ics23.HashOp.SHA256,\n        length: codecimpl_1.ics23.LengthOp.NO_PREFIX,\n        prefix: Uint8Array.from([0]),\n    },\n    innerSpec: {\n        childOrder: [0, 1],\n        childSize: 32,\n        minPrefixLength: 1,\n        maxPrefixLength: 1,\n        emptyChild: new Uint8Array(32),\n        hash: codecimpl_1.ics23.HashOp.SHA256,\n    },\n    maxDepth: 256,\n};\n// verifyExistence will throw an error if the proof doesn't link key, value -> root\n// or if it doesn't fulfill the spec\nfunction verifyExistence(proof, spec, root, key, value) {\n    ensureSpec(proof, spec);\n    const calc = calculateExistenceRoot(proof);\n    (0, specs_1.ensureBytesEqual)(calc, root);\n    (0, specs_1.ensureBytesEqual)(key, proof.key);\n    (0, specs_1.ensureBytesEqual)(value, proof.value);\n}\nexports.verifyExistence = verifyExistence;\n// Verify does all checks to ensure the proof has valid non-existence proofs,\n// and they ensure the given key is not in the CommitmentState,\n// throwing an error if there is an issue\nfunction verifyNonExistence(proof, spec, root, key) {\n    let leftKey;\n    let rightKey;\n    if (proof.left) {\n        verifyExistence(proof.left, spec, root, proof.left.key, proof.left.value);\n        leftKey = proof.left.key;\n    }\n    if (proof.right) {\n        verifyExistence(proof.right, spec, root, proof.right.key, proof.right.value);\n        rightKey = proof.right.key;\n    }\n    if (!leftKey && !rightKey) {\n        throw new Error(\"neither left nor right proof defined\");\n    }\n    if (leftKey) {\n        (0, specs_1.ensureBytesBefore)(leftKey, key);\n    }\n    if (rightKey) {\n        (0, specs_1.ensureBytesBefore)(key, rightKey);\n    }\n    if (!spec.innerSpec) {\n        throw new Error(\"no inner spec\");\n    }\n    if (!leftKey) {\n        ensureLeftMost(spec.innerSpec, proof.right.path);\n    }\n    else if (!rightKey) {\n        ensureRightMost(spec.innerSpec, proof.left.path);\n    }\n    else {\n        ensureLeftNeighbor(spec.innerSpec, proof.left.path, proof.right.path);\n    }\n    return;\n}\nexports.verifyNonExistence = verifyNonExistence;\n// Calculate determines the root hash that matches the given proof.\n// You must validate the result is what you have in a header.\n// Returns error if the calculations cannot be performed.\nfunction calculateExistenceRoot(proof) {\n    if (!proof.key || !proof.value) {\n        throw new Error(\"Existence proof needs key and value set\");\n    }\n    if (!proof.leaf) {\n        throw new Error(\"Existence proof must start with a leaf operation\");\n    }\n    const path = proof.path || [];\n    let res = (0, ops_1.applyLeaf)(proof.leaf, proof.key, proof.value);\n    for (const inner of path) {\n        res = (0, ops_1.applyInner)(inner, res);\n    }\n    return res;\n}\nexports.calculateExistenceRoot = calculateExistenceRoot;\n// ensureSpec throws an Error if proof doesn't fulfill spec\nfunction ensureSpec(proof, spec) {\n    if (!proof.leaf) {\n        throw new Error(\"Existence proof must start with a leaf operation\");\n    }\n    if (!spec.leafSpec) {\n        throw new Error(\"Spec must include leafSpec\");\n    }\n    if (!spec.innerSpec) {\n        throw new Error(\"Spec must include innerSpec\");\n    }\n    (0, specs_1.ensureLeaf)(proof.leaf, spec.leafSpec);\n    const path = proof.path || [];\n    if (spec.minDepth && path.length < spec.minDepth) {\n        throw new Error(`Too few inner nodes ${path.length}`);\n    }\n    if (spec.maxDepth && path.length > spec.maxDepth) {\n        throw new Error(`Too many inner nodes ${path.length}`);\n    }\n    for (const inner of path) {\n        (0, specs_1.ensureInner)(inner, spec.leafSpec.prefix, spec.innerSpec);\n    }\n}\nexports.ensureSpec = ensureSpec;\nfunction ensureLeftMost(spec, path) {\n    const { minPrefix, maxPrefix, suffix } = getPadding(spec, 0);\n    // ensure every step has a prefix and suffix defined to be leftmost\n    for (const step of path) {\n        if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {\n            throw new Error(\"Step not leftmost\");\n        }\n    }\n}\nfunction ensureRightMost(spec, path) {\n    const len = spec.childOrder.length - 1;\n    const { minPrefix, maxPrefix, suffix } = getPadding(spec, len);\n    // ensure every step has a prefix and suffix defined to be leftmost\n    for (const step of path) {\n        if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {\n            throw new Error(\"Step not leftmost\");\n        }\n    }\n}\nfunction ensureLeftNeighbor(spec, left, right) {\n    const mutleft = [...left];\n    const mutright = [...right];\n    let topleft = mutleft.pop();\n    let topright = mutright.pop();\n    while ((0, specs_1.bytesEqual)(topleft.prefix, topright.prefix) &&\n        (0, specs_1.bytesEqual)(topleft.suffix, topright.suffix)) {\n        topleft = mutleft.pop();\n        topright = mutright.pop();\n    }\n    // now topleft and topright are the first divergent nodes\n    // make sure they are left and right of each other\n    if (!isLeftStep(spec, topleft, topright)) {\n        throw new Error(`Not left neightbor at first divergent step`);\n    }\n    // make sure the paths are left and right most possibilities respectively\n    ensureRightMost(spec, mutleft);\n    ensureLeftMost(spec, mutright);\n}\nexports.ensureLeftNeighbor = ensureLeftNeighbor;\n// isLeftStep assumes left and right have common parents\n// checks if left is exactly one slot to the left of right\nfunction isLeftStep(spec, left, right) {\n    const leftidx = orderFromPadding(spec, left);\n    const rightidx = orderFromPadding(spec, right);\n    return rightidx === leftidx + 1;\n}\nfunction orderFromPadding(spec, inner) {\n    for (let branch = 0; branch < spec.childOrder.length; branch++) {\n        const { minPrefix, maxPrefix, suffix } = getPadding(spec, branch);\n        if (hasPadding(inner, minPrefix, maxPrefix, suffix)) {\n            return branch;\n        }\n    }\n    throw new Error(`Cannot find any valid spacing for this node`);\n}\nfunction hasPadding(op, minPrefix, maxPrefix, suffix) {\n    if ((op.prefix || []).length < minPrefix) {\n        return false;\n    }\n    if ((op.prefix || []).length > maxPrefix) {\n        return false;\n    }\n    return (op.suffix || []).length === suffix;\n}\nfunction getPadding(spec, branch) {\n    const idx = getPosition(spec.childOrder, branch);\n    // count how many children are in the prefix\n    const prefix = idx * spec.childSize;\n    const minPrefix = prefix + spec.minPrefixLength;\n    const maxPrefix = prefix + spec.maxPrefixLength;\n    // count how many children are in the suffix\n    const suffix = (spec.childOrder.length - 1 - idx) * spec.childSize;\n    return { minPrefix, maxPrefix, suffix };\n}\nfunction getPosition(order, branch) {\n    if (branch < 0 || branch >= order.length) {\n        throw new Error(`Invalid branch: ${branch}`);\n    }\n    return order.findIndex((val) => val === branch);\n}\n//# sourceMappingURL=proofs.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbmZpby9pY3MyMy9idWlsZC9wcm9vZnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLEdBQUcsa0JBQWtCLEdBQUcsOEJBQThCLEdBQUcsMEJBQTBCLEdBQUcsdUJBQXVCLEdBQUcsZUFBZSxHQUFHLHNCQUFzQixHQUFHLGdCQUFnQjtBQUNyTSxvQkFBb0IsbUJBQU8sQ0FBQyw4RkFBdUI7QUFDbkQsY0FBYyxtQkFBTyxDQUFDLDhEQUFPO0FBQzdCLGdCQUFnQixtQkFBTyxDQUFDLGtFQUFTO0FBQ2pDLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxZQUFZLCtCQUErQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtCQUErQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUNBQWlDO0FBQzFELGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW4tcHJvLW5leHQvLi9ub2RlX21vZHVsZXMvQGNvbmZpby9pY3MyMy9idWlsZC9wcm9vZnMuanM/NGJhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW5zdXJlTGVmdE5laWdoYm9yID0gZXhwb3J0cy5lbnN1cmVTcGVjID0gZXhwb3J0cy5jYWxjdWxhdGVFeGlzdGVuY2VSb290ID0gZXhwb3J0cy52ZXJpZnlOb25FeGlzdGVuY2UgPSBleHBvcnRzLnZlcmlmeUV4aXN0ZW5jZSA9IGV4cG9ydHMuc210U3BlYyA9IGV4cG9ydHMudGVuZGVybWludFNwZWMgPSBleHBvcnRzLmlhdmxTcGVjID0gdm9pZCAwO1xuY29uc3QgY29kZWNpbXBsXzEgPSByZXF1aXJlKFwiLi9nZW5lcmF0ZWQvY29kZWNpbXBsXCIpO1xuY29uc3Qgb3BzXzEgPSByZXF1aXJlKFwiLi9vcHNcIik7XG5jb25zdCBzcGVjc18xID0gcmVxdWlyZShcIi4vc3BlY3NcIik7XG5leHBvcnRzLmlhdmxTcGVjID0ge1xuICAgIGxlYWZTcGVjOiB7XG4gICAgICAgIHByZWZpeDogVWludDhBcnJheS5mcm9tKFswXSksXG4gICAgICAgIGhhc2g6IGNvZGVjaW1wbF8xLmljczIzLkhhc2hPcC5TSEEyNTYsXG4gICAgICAgIHByZWhhc2hWYWx1ZTogY29kZWNpbXBsXzEuaWNzMjMuSGFzaE9wLlNIQTI1NixcbiAgICAgICAgcHJlaGFzaEtleTogY29kZWNpbXBsXzEuaWNzMjMuSGFzaE9wLk5PX0hBU0gsXG4gICAgICAgIGxlbmd0aDogY29kZWNpbXBsXzEuaWNzMjMuTGVuZ3RoT3AuVkFSX1BST1RPLFxuICAgIH0sXG4gICAgaW5uZXJTcGVjOiB7XG4gICAgICAgIGNoaWxkT3JkZXI6IFswLCAxXSxcbiAgICAgICAgbWluUHJlZml4TGVuZ3RoOiA0LFxuICAgICAgICBtYXhQcmVmaXhMZW5ndGg6IDEyLFxuICAgICAgICBjaGlsZFNpemU6IDMzLFxuICAgICAgICBoYXNoOiBjb2RlY2ltcGxfMS5pY3MyMy5IYXNoT3AuU0hBMjU2LFxuICAgIH0sXG59O1xuZXhwb3J0cy50ZW5kZXJtaW50U3BlYyA9IHtcbiAgICBsZWFmU3BlYzoge1xuICAgICAgICBwcmVmaXg6IFVpbnQ4QXJyYXkuZnJvbShbMF0pLFxuICAgICAgICBoYXNoOiBjb2RlY2ltcGxfMS5pY3MyMy5IYXNoT3AuU0hBMjU2LFxuICAgICAgICBwcmVoYXNoVmFsdWU6IGNvZGVjaW1wbF8xLmljczIzLkhhc2hPcC5TSEEyNTYsXG4gICAgICAgIHByZWhhc2hLZXk6IGNvZGVjaW1wbF8xLmljczIzLkhhc2hPcC5OT19IQVNILFxuICAgICAgICBsZW5ndGg6IGNvZGVjaW1wbF8xLmljczIzLkxlbmd0aE9wLlZBUl9QUk9UTyxcbiAgICB9LFxuICAgIGlubmVyU3BlYzoge1xuICAgICAgICBjaGlsZE9yZGVyOiBbMCwgMV0sXG4gICAgICAgIG1pblByZWZpeExlbmd0aDogMSxcbiAgICAgICAgbWF4UHJlZml4TGVuZ3RoOiAxLFxuICAgICAgICBjaGlsZFNpemU6IDMyLFxuICAgICAgICBoYXNoOiBjb2RlY2ltcGxfMS5pY3MyMy5IYXNoT3AuU0hBMjU2LFxuICAgIH0sXG59O1xuZXhwb3J0cy5zbXRTcGVjID0ge1xuICAgIGxlYWZTcGVjOiB7XG4gICAgICAgIGhhc2g6IGNvZGVjaW1wbF8xLmljczIzLkhhc2hPcC5TSEEyNTYsXG4gICAgICAgIHByZWhhc2hLZXk6IGNvZGVjaW1wbF8xLmljczIzLkhhc2hPcC5OT19IQVNILFxuICAgICAgICBwcmVoYXNoVmFsdWU6IGNvZGVjaW1wbF8xLmljczIzLkhhc2hPcC5TSEEyNTYsXG4gICAgICAgIGxlbmd0aDogY29kZWNpbXBsXzEuaWNzMjMuTGVuZ3RoT3AuTk9fUFJFRklYLFxuICAgICAgICBwcmVmaXg6IFVpbnQ4QXJyYXkuZnJvbShbMF0pLFxuICAgIH0sXG4gICAgaW5uZXJTcGVjOiB7XG4gICAgICAgIGNoaWxkT3JkZXI6IFswLCAxXSxcbiAgICAgICAgY2hpbGRTaXplOiAzMixcbiAgICAgICAgbWluUHJlZml4TGVuZ3RoOiAxLFxuICAgICAgICBtYXhQcmVmaXhMZW5ndGg6IDEsXG4gICAgICAgIGVtcHR5Q2hpbGQ6IG5ldyBVaW50OEFycmF5KDMyKSxcbiAgICAgICAgaGFzaDogY29kZWNpbXBsXzEuaWNzMjMuSGFzaE9wLlNIQTI1NixcbiAgICB9LFxuICAgIG1heERlcHRoOiAyNTYsXG59O1xuLy8gdmVyaWZ5RXhpc3RlbmNlIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHByb29mIGRvZXNuJ3QgbGluayBrZXksIHZhbHVlIC0+IHJvb3Rcbi8vIG9yIGlmIGl0IGRvZXNuJ3QgZnVsZmlsbCB0aGUgc3BlY1xuZnVuY3Rpb24gdmVyaWZ5RXhpc3RlbmNlKHByb29mLCBzcGVjLCByb290LCBrZXksIHZhbHVlKSB7XG4gICAgZW5zdXJlU3BlYyhwcm9vZiwgc3BlYyk7XG4gICAgY29uc3QgY2FsYyA9IGNhbGN1bGF0ZUV4aXN0ZW5jZVJvb3QocHJvb2YpO1xuICAgICgwLCBzcGVjc18xLmVuc3VyZUJ5dGVzRXF1YWwpKGNhbGMsIHJvb3QpO1xuICAgICgwLCBzcGVjc18xLmVuc3VyZUJ5dGVzRXF1YWwpKGtleSwgcHJvb2Yua2V5KTtcbiAgICAoMCwgc3BlY3NfMS5lbnN1cmVCeXRlc0VxdWFsKSh2YWx1ZSwgcHJvb2YudmFsdWUpO1xufVxuZXhwb3J0cy52ZXJpZnlFeGlzdGVuY2UgPSB2ZXJpZnlFeGlzdGVuY2U7XG4vLyBWZXJpZnkgZG9lcyBhbGwgY2hlY2tzIHRvIGVuc3VyZSB0aGUgcHJvb2YgaGFzIHZhbGlkIG5vbi1leGlzdGVuY2UgcHJvb2ZzLFxuLy8gYW5kIHRoZXkgZW5zdXJlIHRoZSBnaXZlbiBrZXkgaXMgbm90IGluIHRoZSBDb21taXRtZW50U3RhdGUsXG4vLyB0aHJvd2luZyBhbiBlcnJvciBpZiB0aGVyZSBpcyBhbiBpc3N1ZVxuZnVuY3Rpb24gdmVyaWZ5Tm9uRXhpc3RlbmNlKHByb29mLCBzcGVjLCByb290LCBrZXkpIHtcbiAgICBsZXQgbGVmdEtleTtcbiAgICBsZXQgcmlnaHRLZXk7XG4gICAgaWYgKHByb29mLmxlZnQpIHtcbiAgICAgICAgdmVyaWZ5RXhpc3RlbmNlKHByb29mLmxlZnQsIHNwZWMsIHJvb3QsIHByb29mLmxlZnQua2V5LCBwcm9vZi5sZWZ0LnZhbHVlKTtcbiAgICAgICAgbGVmdEtleSA9IHByb29mLmxlZnQua2V5O1xuICAgIH1cbiAgICBpZiAocHJvb2YucmlnaHQpIHtcbiAgICAgICAgdmVyaWZ5RXhpc3RlbmNlKHByb29mLnJpZ2h0LCBzcGVjLCByb290LCBwcm9vZi5yaWdodC5rZXksIHByb29mLnJpZ2h0LnZhbHVlKTtcbiAgICAgICAgcmlnaHRLZXkgPSBwcm9vZi5yaWdodC5rZXk7XG4gICAgfVxuICAgIGlmICghbGVmdEtleSAmJiAhcmlnaHRLZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibmVpdGhlciBsZWZ0IG5vciByaWdodCBwcm9vZiBkZWZpbmVkXCIpO1xuICAgIH1cbiAgICBpZiAobGVmdEtleSkge1xuICAgICAgICAoMCwgc3BlY3NfMS5lbnN1cmVCeXRlc0JlZm9yZSkobGVmdEtleSwga2V5KTtcbiAgICB9XG4gICAgaWYgKHJpZ2h0S2V5KSB7XG4gICAgICAgICgwLCBzcGVjc18xLmVuc3VyZUJ5dGVzQmVmb3JlKShrZXksIHJpZ2h0S2V5KTtcbiAgICB9XG4gICAgaWYgKCFzcGVjLmlubmVyU3BlYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBpbm5lciBzcGVjXCIpO1xuICAgIH1cbiAgICBpZiAoIWxlZnRLZXkpIHtcbiAgICAgICAgZW5zdXJlTGVmdE1vc3Qoc3BlYy5pbm5lclNwZWMsIHByb29mLnJpZ2h0LnBhdGgpO1xuICAgIH1cbiAgICBlbHNlIGlmICghcmlnaHRLZXkpIHtcbiAgICAgICAgZW5zdXJlUmlnaHRNb3N0KHNwZWMuaW5uZXJTcGVjLCBwcm9vZi5sZWZ0LnBhdGgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZW5zdXJlTGVmdE5laWdoYm9yKHNwZWMuaW5uZXJTcGVjLCBwcm9vZi5sZWZ0LnBhdGgsIHByb29mLnJpZ2h0LnBhdGgpO1xuICAgIH1cbiAgICByZXR1cm47XG59XG5leHBvcnRzLnZlcmlmeU5vbkV4aXN0ZW5jZSA9IHZlcmlmeU5vbkV4aXN0ZW5jZTtcbi8vIENhbGN1bGF0ZSBkZXRlcm1pbmVzIHRoZSByb290IGhhc2ggdGhhdCBtYXRjaGVzIHRoZSBnaXZlbiBwcm9vZi5cbi8vIFlvdSBtdXN0IHZhbGlkYXRlIHRoZSByZXN1bHQgaXMgd2hhdCB5b3UgaGF2ZSBpbiBhIGhlYWRlci5cbi8vIFJldHVybnMgZXJyb3IgaWYgdGhlIGNhbGN1bGF0aW9ucyBjYW5ub3QgYmUgcGVyZm9ybWVkLlxuZnVuY3Rpb24gY2FsY3VsYXRlRXhpc3RlbmNlUm9vdChwcm9vZikge1xuICAgIGlmICghcHJvb2Yua2V5IHx8ICFwcm9vZi52YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeGlzdGVuY2UgcHJvb2YgbmVlZHMga2V5IGFuZCB2YWx1ZSBzZXRcIik7XG4gICAgfVxuICAgIGlmICghcHJvb2YubGVhZikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeGlzdGVuY2UgcHJvb2YgbXVzdCBzdGFydCB3aXRoIGEgbGVhZiBvcGVyYXRpb25cIik7XG4gICAgfVxuICAgIGNvbnN0IHBhdGggPSBwcm9vZi5wYXRoIHx8IFtdO1xuICAgIGxldCByZXMgPSAoMCwgb3BzXzEuYXBwbHlMZWFmKShwcm9vZi5sZWFmLCBwcm9vZi5rZXksIHByb29mLnZhbHVlKTtcbiAgICBmb3IgKGNvbnN0IGlubmVyIG9mIHBhdGgpIHtcbiAgICAgICAgcmVzID0gKDAsIG9wc18xLmFwcGx5SW5uZXIpKGlubmVyLCByZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5jYWxjdWxhdGVFeGlzdGVuY2VSb290ID0gY2FsY3VsYXRlRXhpc3RlbmNlUm9vdDtcbi8vIGVuc3VyZVNwZWMgdGhyb3dzIGFuIEVycm9yIGlmIHByb29mIGRvZXNuJ3QgZnVsZmlsbCBzcGVjXG5mdW5jdGlvbiBlbnN1cmVTcGVjKHByb29mLCBzcGVjKSB7XG4gICAgaWYgKCFwcm9vZi5sZWFmKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4aXN0ZW5jZSBwcm9vZiBtdXN0IHN0YXJ0IHdpdGggYSBsZWFmIG9wZXJhdGlvblwiKTtcbiAgICB9XG4gICAgaWYgKCFzcGVjLmxlYWZTcGVjKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNwZWMgbXVzdCBpbmNsdWRlIGxlYWZTcGVjXCIpO1xuICAgIH1cbiAgICBpZiAoIXNwZWMuaW5uZXJTcGVjKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNwZWMgbXVzdCBpbmNsdWRlIGlubmVyU3BlY1wiKTtcbiAgICB9XG4gICAgKDAsIHNwZWNzXzEuZW5zdXJlTGVhZikocHJvb2YubGVhZiwgc3BlYy5sZWFmU3BlYyk7XG4gICAgY29uc3QgcGF0aCA9IHByb29mLnBhdGggfHwgW107XG4gICAgaWYgKHNwZWMubWluRGVwdGggJiYgcGF0aC5sZW5ndGggPCBzcGVjLm1pbkRlcHRoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVG9vIGZldyBpbm5lciBub2RlcyAke3BhdGgubGVuZ3RofWApO1xuICAgIH1cbiAgICBpZiAoc3BlYy5tYXhEZXB0aCAmJiBwYXRoLmxlbmd0aCA+IHNwZWMubWF4RGVwdGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUb28gbWFueSBpbm5lciBub2RlcyAke3BhdGgubGVuZ3RofWApO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGlubmVyIG9mIHBhdGgpIHtcbiAgICAgICAgKDAsIHNwZWNzXzEuZW5zdXJlSW5uZXIpKGlubmVyLCBzcGVjLmxlYWZTcGVjLnByZWZpeCwgc3BlYy5pbm5lclNwZWMpO1xuICAgIH1cbn1cbmV4cG9ydHMuZW5zdXJlU3BlYyA9IGVuc3VyZVNwZWM7XG5mdW5jdGlvbiBlbnN1cmVMZWZ0TW9zdChzcGVjLCBwYXRoKSB7XG4gICAgY29uc3QgeyBtaW5QcmVmaXgsIG1heFByZWZpeCwgc3VmZml4IH0gPSBnZXRQYWRkaW5nKHNwZWMsIDApO1xuICAgIC8vIGVuc3VyZSBldmVyeSBzdGVwIGhhcyBhIHByZWZpeCBhbmQgc3VmZml4IGRlZmluZWQgdG8gYmUgbGVmdG1vc3RcbiAgICBmb3IgKGNvbnN0IHN0ZXAgb2YgcGF0aCkge1xuICAgICAgICBpZiAoIWhhc1BhZGRpbmcoc3RlcCwgbWluUHJlZml4LCBtYXhQcmVmaXgsIHN1ZmZpeCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0ZXAgbm90IGxlZnRtb3N0XCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZW5zdXJlUmlnaHRNb3N0KHNwZWMsIHBhdGgpIHtcbiAgICBjb25zdCBsZW4gPSBzcGVjLmNoaWxkT3JkZXIubGVuZ3RoIC0gMTtcbiAgICBjb25zdCB7IG1pblByZWZpeCwgbWF4UHJlZml4LCBzdWZmaXggfSA9IGdldFBhZGRpbmcoc3BlYywgbGVuKTtcbiAgICAvLyBlbnN1cmUgZXZlcnkgc3RlcCBoYXMgYSBwcmVmaXggYW5kIHN1ZmZpeCBkZWZpbmVkIHRvIGJlIGxlZnRtb3N0XG4gICAgZm9yIChjb25zdCBzdGVwIG9mIHBhdGgpIHtcbiAgICAgICAgaWYgKCFoYXNQYWRkaW5nKHN0ZXAsIG1pblByZWZpeCwgbWF4UHJlZml4LCBzdWZmaXgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGVwIG5vdCBsZWZ0bW9zdFwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGVuc3VyZUxlZnROZWlnaGJvcihzcGVjLCBsZWZ0LCByaWdodCkge1xuICAgIGNvbnN0IG11dGxlZnQgPSBbLi4ubGVmdF07XG4gICAgY29uc3QgbXV0cmlnaHQgPSBbLi4ucmlnaHRdO1xuICAgIGxldCB0b3BsZWZ0ID0gbXV0bGVmdC5wb3AoKTtcbiAgICBsZXQgdG9wcmlnaHQgPSBtdXRyaWdodC5wb3AoKTtcbiAgICB3aGlsZSAoKDAsIHNwZWNzXzEuYnl0ZXNFcXVhbCkodG9wbGVmdC5wcmVmaXgsIHRvcHJpZ2h0LnByZWZpeCkgJiZcbiAgICAgICAgKDAsIHNwZWNzXzEuYnl0ZXNFcXVhbCkodG9wbGVmdC5zdWZmaXgsIHRvcHJpZ2h0LnN1ZmZpeCkpIHtcbiAgICAgICAgdG9wbGVmdCA9IG11dGxlZnQucG9wKCk7XG4gICAgICAgIHRvcHJpZ2h0ID0gbXV0cmlnaHQucG9wKCk7XG4gICAgfVxuICAgIC8vIG5vdyB0b3BsZWZ0IGFuZCB0b3ByaWdodCBhcmUgdGhlIGZpcnN0IGRpdmVyZ2VudCBub2Rlc1xuICAgIC8vIG1ha2Ugc3VyZSB0aGV5IGFyZSBsZWZ0IGFuZCByaWdodCBvZiBlYWNoIG90aGVyXG4gICAgaWYgKCFpc0xlZnRTdGVwKHNwZWMsIHRvcGxlZnQsIHRvcHJpZ2h0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBsZWZ0IG5laWdodGJvciBhdCBmaXJzdCBkaXZlcmdlbnQgc3RlcGApO1xuICAgIH1cbiAgICAvLyBtYWtlIHN1cmUgdGhlIHBhdGhzIGFyZSBsZWZ0IGFuZCByaWdodCBtb3N0IHBvc3NpYmlsaXRpZXMgcmVzcGVjdGl2ZWx5XG4gICAgZW5zdXJlUmlnaHRNb3N0KHNwZWMsIG11dGxlZnQpO1xuICAgIGVuc3VyZUxlZnRNb3N0KHNwZWMsIG11dHJpZ2h0KTtcbn1cbmV4cG9ydHMuZW5zdXJlTGVmdE5laWdoYm9yID0gZW5zdXJlTGVmdE5laWdoYm9yO1xuLy8gaXNMZWZ0U3RlcCBhc3N1bWVzIGxlZnQgYW5kIHJpZ2h0IGhhdmUgY29tbW9uIHBhcmVudHNcbi8vIGNoZWNrcyBpZiBsZWZ0IGlzIGV4YWN0bHkgb25lIHNsb3QgdG8gdGhlIGxlZnQgb2YgcmlnaHRcbmZ1bmN0aW9uIGlzTGVmdFN0ZXAoc3BlYywgbGVmdCwgcmlnaHQpIHtcbiAgICBjb25zdCBsZWZ0aWR4ID0gb3JkZXJGcm9tUGFkZGluZyhzcGVjLCBsZWZ0KTtcbiAgICBjb25zdCByaWdodGlkeCA9IG9yZGVyRnJvbVBhZGRpbmcoc3BlYywgcmlnaHQpO1xuICAgIHJldHVybiByaWdodGlkeCA9PT0gbGVmdGlkeCArIDE7XG59XG5mdW5jdGlvbiBvcmRlckZyb21QYWRkaW5nKHNwZWMsIGlubmVyKSB7XG4gICAgZm9yIChsZXQgYnJhbmNoID0gMDsgYnJhbmNoIDwgc3BlYy5jaGlsZE9yZGVyLmxlbmd0aDsgYnJhbmNoKyspIHtcbiAgICAgICAgY29uc3QgeyBtaW5QcmVmaXgsIG1heFByZWZpeCwgc3VmZml4IH0gPSBnZXRQYWRkaW5nKHNwZWMsIGJyYW5jaCk7XG4gICAgICAgIGlmIChoYXNQYWRkaW5nKGlubmVyLCBtaW5QcmVmaXgsIG1heFByZWZpeCwgc3VmZml4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGJyYW5jaDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaW5kIGFueSB2YWxpZCBzcGFjaW5nIGZvciB0aGlzIG5vZGVgKTtcbn1cbmZ1bmN0aW9uIGhhc1BhZGRpbmcob3AsIG1pblByZWZpeCwgbWF4UHJlZml4LCBzdWZmaXgpIHtcbiAgICBpZiAoKG9wLnByZWZpeCB8fCBbXSkubGVuZ3RoIDwgbWluUHJlZml4KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKChvcC5wcmVmaXggfHwgW10pLmxlbmd0aCA+IG1heFByZWZpeCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAob3Auc3VmZml4IHx8IFtdKS5sZW5ndGggPT09IHN1ZmZpeDtcbn1cbmZ1bmN0aW9uIGdldFBhZGRpbmcoc3BlYywgYnJhbmNoKSB7XG4gICAgY29uc3QgaWR4ID0gZ2V0UG9zaXRpb24oc3BlYy5jaGlsZE9yZGVyLCBicmFuY2gpO1xuICAgIC8vIGNvdW50IGhvdyBtYW55IGNoaWxkcmVuIGFyZSBpbiB0aGUgcHJlZml4XG4gICAgY29uc3QgcHJlZml4ID0gaWR4ICogc3BlYy5jaGlsZFNpemU7XG4gICAgY29uc3QgbWluUHJlZml4ID0gcHJlZml4ICsgc3BlYy5taW5QcmVmaXhMZW5ndGg7XG4gICAgY29uc3QgbWF4UHJlZml4ID0gcHJlZml4ICsgc3BlYy5tYXhQcmVmaXhMZW5ndGg7XG4gICAgLy8gY291bnQgaG93IG1hbnkgY2hpbGRyZW4gYXJlIGluIHRoZSBzdWZmaXhcbiAgICBjb25zdCBzdWZmaXggPSAoc3BlYy5jaGlsZE9yZGVyLmxlbmd0aCAtIDEgLSBpZHgpICogc3BlYy5jaGlsZFNpemU7XG4gICAgcmV0dXJuIHsgbWluUHJlZml4LCBtYXhQcmVmaXgsIHN1ZmZpeCB9O1xufVxuZnVuY3Rpb24gZ2V0UG9zaXRpb24ob3JkZXIsIGJyYW5jaCkge1xuICAgIGlmIChicmFuY2ggPCAwIHx8IGJyYW5jaCA+PSBvcmRlci5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJyYW5jaDogJHticmFuY2h9YCk7XG4gICAgfVxuICAgIHJldHVybiBvcmRlci5maW5kSW5kZXgoKHZhbCkgPT4gdmFsID09PSBicmFuY2gpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvb2ZzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@confio/ics23/build/proofs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@confio/ics23/build/specs.js":
/*!***************************************************!*\
  !*** ./node_modules/@confio/ics23/build/specs.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bytesBefore = exports.ensureBytesBefore = exports.bytesEqual = exports.ensureBytesEqual = exports.ensureInner = exports.ensureLeaf = void 0;\nfunction ensureLeaf(leaf, spec) {\n    if (leaf.hash !== spec.hash) {\n        throw new Error(`Unexpected hashOp: ${leaf.hash}`);\n    }\n    if (leaf.prehashKey !== spec.prehashKey) {\n        throw new Error(`Unexpected prehashKey: ${leaf.prehashKey}`);\n    }\n    if (leaf.prehashValue !== spec.prehashValue) {\n        throw new Error(`Unexpected prehashValue: ${leaf.prehashValue}`);\n    }\n    if (leaf.length !== spec.length) {\n        throw new Error(`Unexpected length op: ${leaf.length}`);\n    }\n    ensurePrefix(leaf.prefix, spec.prefix);\n}\nexports.ensureLeaf = ensureLeaf;\nfunction ensureInner(inner, prefix, spec) {\n    if (inner.hash !== spec.hash) {\n        throw new Error(`Unexpected hashOp: ${inner.hash}`);\n    }\n    if (!inner.prefix) {\n        throw new Error(\"No prefix set for inner node\");\n    }\n    if (hasPrefix(inner.prefix, prefix)) {\n        throw new Error(`Inner node has leaf prefix`);\n    }\n    if (inner.prefix.length < (spec.minPrefixLength || 0)) {\n        throw new Error(`Prefix too short: ${inner.prefix.length} bytes`);\n    }\n    const maxLeftChildBytes = (spec.childOrder.length - 1) * spec.childSize;\n    if (inner.prefix.length > (spec.maxPrefixLength || 0) + maxLeftChildBytes) {\n        throw new Error(`Prefix too long: ${inner.prefix.length} bytes`);\n    }\n}\nexports.ensureInner = ensureInner;\nfunction ensurePrefix(check, prefix) {\n    // no prefix supplied, means everything passes\n    if (!prefix || prefix.length === 0) {\n        return;\n    }\n    if (!check) {\n        throw new Error(`Target bytes missing`);\n    }\n    ensureBytesEqual(prefix, check.slice(0, prefix.length));\n}\n// ensureBytesEqual throws an error if the arrays are different\nfunction ensureBytesEqual(a, b) {\n    if (a.length !== b.length) {\n        throw new Error(`Different lengths ${a.length} vs ${b.length}`);\n    }\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            throw new Error(`Arrays differ at index ${i}: ${a[i]} vs ${b[i]}`);\n        }\n    }\n}\nexports.ensureBytesEqual = ensureBytesEqual;\nfunction bytesEqual(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.bytesEqual = bytesEqual;\nfunction hasPrefix(check, prefix) {\n    // no prefix supplied, means everything passes\n    if (!prefix || prefix.length === 0) {\n        return false;\n    }\n    if (!check) {\n        return false;\n    }\n    if (check.length <= prefix.length) {\n        return false;\n    }\n    for (let i = 0; i < prefix.length; i++) {\n        if (check[i] !== prefix[i]) {\n            return false;\n        }\n    }\n    throw true;\n}\n// ensureBytesBefore throws an error if first >= last\n// we compare byte by byte\nfunction ensureBytesBefore(first, last) {\n    if (!bytesBefore(first, last)) {\n        throw new Error(\"first is after last\");\n    }\n}\nexports.ensureBytesBefore = ensureBytesBefore;\nfunction bytesBefore(first, last) {\n    const min = first.length < last.length ? first.length : last.length;\n    for (let i = 0; i < min; i++) {\n        if (first[i] < last[i]) {\n            return true;\n        }\n        if (first[i] > last[i]) {\n            return false;\n        }\n        // if they are equal, continue to next step\n    }\n    // if they match, ensure that last is longer than first..\n    return first.length < last.length;\n}\nexports.bytesBefore = bytesBefore;\n//# sourceMappingURL=specs.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbmZpby9pY3MyMy9idWlsZC9zcGVjcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyx5QkFBeUIsR0FBRyxrQkFBa0IsR0FBRyx3QkFBd0IsR0FBRyxtQkFBbUIsR0FBRyxrQkFBa0I7QUFDMUk7QUFDQTtBQUNBLDhDQUE4QyxVQUFVO0FBQ3hEO0FBQ0E7QUFDQSxrREFBa0QsZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCO0FBQ3RFO0FBQ0E7QUFDQSxpREFBaUQsWUFBWTtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLDhDQUE4QyxXQUFXO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMscUJBQXFCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxxQkFBcUI7QUFDakU7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxVQUFVLEtBQUssU0FBUztBQUNyRTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0Esc0RBQXNELEVBQUUsSUFBSSxNQUFNLEtBQUssS0FBSztBQUM1RTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVuLXByby1uZXh0Ly4vbm9kZV9tb2R1bGVzL0Bjb25maW8vaWNzMjMvYnVpbGQvc3BlY3MuanM/NDcwZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYnl0ZXNCZWZvcmUgPSBleHBvcnRzLmVuc3VyZUJ5dGVzQmVmb3JlID0gZXhwb3J0cy5ieXRlc0VxdWFsID0gZXhwb3J0cy5lbnN1cmVCeXRlc0VxdWFsID0gZXhwb3J0cy5lbnN1cmVJbm5lciA9IGV4cG9ydHMuZW5zdXJlTGVhZiA9IHZvaWQgMDtcbmZ1bmN0aW9uIGVuc3VyZUxlYWYobGVhZiwgc3BlYykge1xuICAgIGlmIChsZWFmLmhhc2ggIT09IHNwZWMuaGFzaCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaGFzaE9wOiAke2xlYWYuaGFzaH1gKTtcbiAgICB9XG4gICAgaWYgKGxlYWYucHJlaGFzaEtleSAhPT0gc3BlYy5wcmVoYXNoS2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBwcmVoYXNoS2V5OiAke2xlYWYucHJlaGFzaEtleX1gKTtcbiAgICB9XG4gICAgaWYgKGxlYWYucHJlaGFzaFZhbHVlICE9PSBzcGVjLnByZWhhc2hWYWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgcHJlaGFzaFZhbHVlOiAke2xlYWYucHJlaGFzaFZhbHVlfWApO1xuICAgIH1cbiAgICBpZiAobGVhZi5sZW5ndGggIT09IHNwZWMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBsZW5ndGggb3A6ICR7bGVhZi5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGVuc3VyZVByZWZpeChsZWFmLnByZWZpeCwgc3BlYy5wcmVmaXgpO1xufVxuZXhwb3J0cy5lbnN1cmVMZWFmID0gZW5zdXJlTGVhZjtcbmZ1bmN0aW9uIGVuc3VyZUlubmVyKGlubmVyLCBwcmVmaXgsIHNwZWMpIHtcbiAgICBpZiAoaW5uZXIuaGFzaCAhPT0gc3BlYy5oYXNoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBoYXNoT3A6ICR7aW5uZXIuaGFzaH1gKTtcbiAgICB9XG4gICAgaWYgKCFpbm5lci5wcmVmaXgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcHJlZml4IHNldCBmb3IgaW5uZXIgbm9kZVwiKTtcbiAgICB9XG4gICAgaWYgKGhhc1ByZWZpeChpbm5lci5wcmVmaXgsIHByZWZpeCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbm5lciBub2RlIGhhcyBsZWFmIHByZWZpeGApO1xuICAgIH1cbiAgICBpZiAoaW5uZXIucHJlZml4Lmxlbmd0aCA8IChzcGVjLm1pblByZWZpeExlbmd0aCB8fCAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByZWZpeCB0b28gc2hvcnQ6ICR7aW5uZXIucHJlZml4Lmxlbmd0aH0gYnl0ZXNgKTtcbiAgICB9XG4gICAgY29uc3QgbWF4TGVmdENoaWxkQnl0ZXMgPSAoc3BlYy5jaGlsZE9yZGVyLmxlbmd0aCAtIDEpICogc3BlYy5jaGlsZFNpemU7XG4gICAgaWYgKGlubmVyLnByZWZpeC5sZW5ndGggPiAoc3BlYy5tYXhQcmVmaXhMZW5ndGggfHwgMCkgKyBtYXhMZWZ0Q2hpbGRCeXRlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByZWZpeCB0b28gbG9uZzogJHtpbm5lci5wcmVmaXgubGVuZ3RofSBieXRlc2ApO1xuICAgIH1cbn1cbmV4cG9ydHMuZW5zdXJlSW5uZXIgPSBlbnN1cmVJbm5lcjtcbmZ1bmN0aW9uIGVuc3VyZVByZWZpeChjaGVjaywgcHJlZml4KSB7XG4gICAgLy8gbm8gcHJlZml4IHN1cHBsaWVkLCBtZWFucyBldmVyeXRoaW5nIHBhc3Nlc1xuICAgIGlmICghcHJlZml4IHx8IHByZWZpeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNoZWNrKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGFyZ2V0IGJ5dGVzIG1pc3NpbmdgKTtcbiAgICB9XG4gICAgZW5zdXJlQnl0ZXNFcXVhbChwcmVmaXgsIGNoZWNrLnNsaWNlKDAsIHByZWZpeC5sZW5ndGgpKTtcbn1cbi8vIGVuc3VyZUJ5dGVzRXF1YWwgdGhyb3dzIGFuIGVycm9yIGlmIHRoZSBhcnJheXMgYXJlIGRpZmZlcmVudFxuZnVuY3Rpb24gZW5zdXJlQnl0ZXNFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpZmZlcmVudCBsZW5ndGhzICR7YS5sZW5ndGh9IHZzICR7Yi5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBcnJheXMgZGlmZmVyIGF0IGluZGV4ICR7aX06ICR7YVtpXX0gdnMgJHtiW2ldfWApO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5lbnN1cmVCeXRlc0VxdWFsID0gZW5zdXJlQnl0ZXNFcXVhbDtcbmZ1bmN0aW9uIGJ5dGVzRXF1YWwoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuYnl0ZXNFcXVhbCA9IGJ5dGVzRXF1YWw7XG5mdW5jdGlvbiBoYXNQcmVmaXgoY2hlY2ssIHByZWZpeCkge1xuICAgIC8vIG5vIHByZWZpeCBzdXBwbGllZCwgbWVhbnMgZXZlcnl0aGluZyBwYXNzZXNcbiAgICBpZiAoIXByZWZpeCB8fCBwcmVmaXgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFjaGVjaykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChjaGVjay5sZW5ndGggPD0gcHJlZml4Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjaGVja1tpXSAhPT0gcHJlZml4W2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgdHJ1ZTtcbn1cbi8vIGVuc3VyZUJ5dGVzQmVmb3JlIHRocm93cyBhbiBlcnJvciBpZiBmaXJzdCA+PSBsYXN0XG4vLyB3ZSBjb21wYXJlIGJ5dGUgYnkgYnl0ZVxuZnVuY3Rpb24gZW5zdXJlQnl0ZXNCZWZvcmUoZmlyc3QsIGxhc3QpIHtcbiAgICBpZiAoIWJ5dGVzQmVmb3JlKGZpcnN0LCBsYXN0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXJzdCBpcyBhZnRlciBsYXN0XCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuZW5zdXJlQnl0ZXNCZWZvcmUgPSBlbnN1cmVCeXRlc0JlZm9yZTtcbmZ1bmN0aW9uIGJ5dGVzQmVmb3JlKGZpcnN0LCBsYXN0KSB7XG4gICAgY29uc3QgbWluID0gZmlyc3QubGVuZ3RoIDwgbGFzdC5sZW5ndGggPyBmaXJzdC5sZW5ndGggOiBsYXN0Lmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1pbjsgaSsrKSB7XG4gICAgICAgIGlmIChmaXJzdFtpXSA8IGxhc3RbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdFtpXSA+IGxhc3RbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGV5IGFyZSBlcXVhbCwgY29udGludWUgdG8gbmV4dCBzdGVwXG4gICAgfVxuICAgIC8vIGlmIHRoZXkgbWF0Y2gsIGVuc3VyZSB0aGF0IGxhc3QgaXMgbG9uZ2VyIHRoYW4gZmlyc3QuLlxuICAgIHJldHVybiBmaXJzdC5sZW5ndGggPCBsYXN0Lmxlbmd0aDtcbn1cbmV4cG9ydHMuYnl0ZXNCZWZvcmUgPSBieXRlc0JlZm9yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwZWNzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@confio/ics23/build/specs.js\n");

/***/ })

};
;